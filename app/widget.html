<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="widget-version" content="1.0.0">
    <meta name="build-date" content="2026-01-31">
    <title>SideDrawer Integration</title>
    <!-- Zoho CRM SDK -->
    <script src="https://live.zwidgets.com/js-sdk/1.2/ZohoEmbededAppSDK.min.js"></script>
    <!-- Stripe.js for PCI-compliant payment processing -->
    <script src="https://js.stripe.com/v3/"></script>
    <!-- External resources loaded dynamically with cache-busting (see script below) -->
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>SideDrawer Integration</h1>
        <p>Connect your Zoho CRM with SideDrawer</p>
      </div>

      <div id="app-content">
        <div class="loading">
          <div class="spinner"></div>
          <p>Initializing connection...</p>
        </div>
      </div>
      
      <!-- Tenant Creation Wizard Container (hidden by default) -->
      <div id="tenant-wizard" class="hidden"></div>
    </div>

      <script>
      // Read URL parameters for initial config
      const urlParams = new URLSearchParams(window.location.search);
      const isOAuthCallback = urlParams.has('code') || urlParams.has('error');
      
      // Helper to get config param (from URL or sessionStorage)
      function getConfigParam(key) {
        // If URL has param, use and store it
        if (urlParams.has(key)) {
          const value = urlParams.get(key);
          if (!isOAuthCallback) {
            sessionStorage.setItem('sd_config_' + key, value);
          }
          return value;
        }
        // Otherwise try sessionStorage
        return sessionStorage.getItem('sd_config_' + key) || null;
      }
      
      // OAuth2 Configuration (will be updated with Zoho config if available)
      const OAUTH_CONFIG = {
        authorizationEndpoint: 'https://auth-sbx.sidedrawersbx.com/authorize',
        tokenEndpoint: 'https://auth-sbx.sidedrawersbx.com/oauth/token',
        clientId: getConfigParam('client_id') || null,
        audience: 'https://user-api-sbx.sidedrawersbx.com',
        redirectUri: getConfigParam('redirect_uri') || (window.location.origin + window.location.pathname.split('?')[0]),
        scope: 'openid profile email offline_access'
      };
      
      // Log initial configuration
      console.log('üîß Initial OAuth Config (PKCE - NO CLIENT SECRET):');
      console.log('  Client ID:', OAUTH_CONFIG.clientId ? 'Set' : 'NOT SET');
      console.log('  Redirect URI:', OAUTH_CONFIG.redirectUri);
      console.log('  Is OAuth Callback:', isOAuthCallback);

      // Define reset functions IMMEDIATELY (before any async operations)
      window.resetSideDrawerConfig = async function() {
        if (!window.auth) {
          console.error('‚ùå Auth instance not available. Using simple reset...');
          window.resetSideDrawerConfigSimple();
          return;
        }
        if (confirm('Are you sure you want to reset all SideDrawer configuration? This will clear credentials and sessions.')) {
          await window.auth.resetConfiguration();
        }
      };

      window.resetSideDrawerConfigSimple = function() {
        if (confirm('Reset all SideDrawer configuration? This will clear all stored data.')) {
          // Clear localStorage
          localStorage.removeItem('sd_widget_setup_config');
          localStorage.removeItem('sdSession');
          localStorage.removeItem('sidedrawer_refresh_token');
          localStorage.removeItem('sidedrawer_code_verifier');
          
          // Clear all localStorage items related to SideDrawer and Auth0
          Object.keys(localStorage).forEach(key => {
            if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
              localStorage.removeItem(key);
            }
          });
          
          // Clear sessionStorage
          Object.keys(sessionStorage).forEach(key => {
            if (key.startsWith('sd_config_')) {
              sessionStorage.removeItem(key);
            }
          });
          
          sessionStorage.removeItem('sidedrawer_code_verifier');
          
          console.log('‚úÖ Local storage cleared. Refreshing page...');
          window.location.reload();
        }
      };

      console.log('‚úÖ Reset functions available: resetSideDrawerConfig(), resetSideDrawerConfigSimple()');
      console.log('‚úÖ Reset functions loaded:', {
        resetSideDrawerConfig: typeof window.resetSideDrawerConfig,
        resetSideDrawerConfigSimple: typeof window.resetSideDrawerConfigSimple
      });

      // Widget version for cache verification
      const WIDGET_VERSION = '1.0.0';
      const BUILD_DATE = '2026-01-31';

      // Log version information
      console.log('üì¶ SideDrawer Widget Version:', WIDGET_VERSION);
      console.log('üìÖ Build Date:', BUILD_DATE);
      console.log('üîó Loaded from:', window.location.href);

      // Dynamic resource loader with automatic cache-busting
      function loadResource(url, type = 'script') {
        return new Promise((resolve, reject) => {
          // Use BUILD_DATE + timestamp for automatic cache-busting (no manual version params needed)
          const cacheBuster = BUILD_DATE.replace(/-/g, '') + '_' + Date.now();
          const separator = url.includes('?') ? '&' : '?';
          const urlWithCache = url + separator + 'cb=' + cacheBuster;
          
          console.log(`[Resource Loader] Loading ${type}: ${urlWithCache}`);
          
          if (type === 'script') {
            const script = document.createElement('script');
            script.src = urlWithCache;
            script.onload = () => {
              console.log(`‚úÖ Loaded script: ${url}`);
              resolve();
            };
            script.onerror = () => {
              console.error(`‚ùå Failed to load script: ${url}`);
              reject(new Error(`Failed to load script: ${url}`));
            };
            document.head.appendChild(script);
          } else if (type === 'stylesheet') {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = urlWithCache;
            link.onload = () => {
              console.log(`‚úÖ Loaded stylesheet: ${url}`);
              resolve();
            };
            link.onerror = () => {
              console.error(`‚ùå Failed to load stylesheet: ${url}`);
              reject(new Error(`Failed to load stylesheet: ${url}`));
            };
            document.head.appendChild(link);
          }
        });
      }

      // Load external resources with automatic cache-busting
      // This ensures all resources refresh when BUILD_DATE changes
      const resourcesToLoad = [
        { url: 'widget.css', type: 'stylesheet' },
        { url: 'tenant-wizard.js', type: 'script' },
        { url: 'tenant-wizard-with-credentials.js', type: 'script' },
        { url: 'setup-api.js', type: 'script' },
        { url: 'setup-modal.js', type: 'script' },
        { url: 'account-selection-modal.js', type: 'script' }
      ];

      // Store promise for resource loading to ensure initialization waits
      window.resourcesLoadedPromise = Promise.all(
        resourcesToLoad.map(resource => loadResource(resource.url, resource.type))
      ).then(() => {
        console.log('‚úÖ All external resources loaded with cache-busting');
        return true;
      }).catch(error => {
        console.error('‚ùå Error loading external resources:', error);
        // Continue anyway - some resources might still work
        return false;
      });

      // Storage keys
      const STORAGE_KEYS = {
        refreshToken: 'sidedrawer_refresh_token', // Persistent in localStorage
        codeVerifier: 'sidedrawer_code_verifier'
      };

      const ZOHO_SESSION_KEY = 'sdSession'; // Zoho session storage key
      
      // Helper function to extract Auth0 domain from authorization endpoint
      function getAuth0Domain() {
        try {
          const url = new URL(OAUTH_CONFIG.authorizationEndpoint);
          return url.origin; // Returns https://auth-sbx.sidedrawersbx.com or https://auth.sidedrawer.com
        } catch (e) {
          console.error('Failed to parse Auth0 domain:', e);
          return 'https://auth-sbx.sidedrawersbx.com'; // Fallback to sandbox
        }
      }

      class SideDrawerAuth {
        constructor() {
          this.zohoInitialized = false;
          this.refreshInterval = null;
          this.hasManageOrgPermission = false; // Store permission status
          this.setupModal = null; // Setup modal instance
          this.accountSelectionModal = null; // Account selection modal instance
          this.initZoho();
        }

        async initZoho() {
          // Helper function to extract client_id from sd_config_redirect_uri sessionStorage
          const extractClientIdFromRedirectUri = () => {
            const redirectUri = sessionStorage.getItem('sd_config_redirect_uri');
            if (redirectUri) {
              try {
                const url = new URL(redirectUri);
                const clientId = url.searchParams.get('client_id');
                if (clientId) {
                  console.log('[SideDrawer Widget] ‚úì Extracted client_id from redirect_uri:', clientId);
                  return clientId;
                }
              } catch (e) {
                console.warn('[SideDrawer Widget] Failed to parse redirect_uri:', e);
              }
            }
            return null;
          };
          
          // Helper function to get client_id from multiple sources
          const getClientId = () => {
            // Priority 1: URL params
            const urlClientId = urlParams.get('client_id');
            if (urlClientId) {
              return urlClientId;
            }
            
            // Priority 2: Extract from sd_config_redirect_uri
            const redirectUriClientId = extractClientIdFromRedirectUri();
            if (redirectUriClientId) {
              return redirectUriClientId;
            }
            
            // Priority 3: From OAUTH_CONFIG (which may have been set from sessionStorage)
            if (OAUTH_CONFIG.clientId) {
              return OAUTH_CONFIG.clientId;
            }
            
            return null;
          };
          
          // When loaded in Zoho, respond to postMessage requests for session data
          window.addEventListener('message', async (event) => {
            // Handle REFRESH_SIDEDRAWER_TOKEN message
            if (event.data && event.data.type === 'REFRESH_SIDEDRAWER_TOKEN') {
              console.log('[SideDrawer Widget] üîÑ Received token refresh request');
              
              try {
                // Get client_id from multiple sources
                const clientId = getClientId();
                
                if (!clientId) {
                  throw new Error('client_id not found in URL params, redirect_uri, or sessionStorage');
                }
                
                // Update OAUTH_CONFIG.clientId if needed
                if (!OAUTH_CONFIG.clientId) {
                  OAUTH_CONFIG.clientId = clientId;
                  console.log('[SideDrawer Widget] ‚úì Set OAUTH_CONFIG.clientId from getClientId():', clientId);
                }
                
                console.log('[SideDrawer Widget] Client ID for refresh:', clientId);
                
                // Call the existing refreshAccessToken method
                await this.refreshAccessToken();
                
                // Get the refreshed session
                const refreshedSession = await this.getZohoSession();
                
                if (refreshedSession && refreshedSession.accessToken) {
                  // Ensure clientId is in session
                  if (!refreshedSession.clientId) {
                    refreshedSession.clientId = clientId;
                  }
                  
                  console.log('[SideDrawer Widget] ‚úÖ Token refreshed successfully');
                  console.log('[SideDrawer Widget] New token expires at:', refreshedSession.expiresAt ? new Date(parseInt(refreshedSession.expiresAt)).toISOString() : 'N/A');
                  
                  // Send refreshed session back to parent
                  window.parent.postMessage({
                    type: 'SIDEDRAWER_SESSION_RESPONSE',
                    session: refreshedSession
                  }, '*');
                } else {
                  throw new Error('Failed to get refreshed session after token refresh');
                }
                
              } catch (error) {
                console.error('[SideDrawer Widget] ‚ùå Token refresh error:', error);
                window.parent.postMessage({
                  type: 'SIDEDRAWER_SESSION_RESPONSE',
                  session: null,
                  error: error.message
                }, '*');
              }
              
              return; // Exit early, don't process REQUEST_SIDEDRAWER_SESSION
            }
            
            // Handle REQUEST_SIDEDRAWER_SESSION message
            if (event.data && event.data.type === 'REQUEST_SIDEDRAWER_SESSION') {
              console.log('üì• Received session request from parent window');
              const session = localStorage.getItem('sdSession');
              if (session) {
                try {
                  const sessionData = JSON.parse(session);
                  
                  // Ensure clientId is in session (extract from multiple sources if missing)
                  if (!sessionData.clientId) {
                    const clientId = getClientId();
                    if (clientId) {
                      sessionData.clientId = clientId;
                      // Update stored session with clientId
                      localStorage.setItem('sdSession', JSON.stringify(sessionData));
                    }
                  }
                  
                  window.parent.postMessage({
                    type: 'SIDEDRAWER_SESSION_RESPONSE',
                    session: sessionData
                  }, '*');
                  console.log('üì§ Sent session to parent window');
                } catch (e) {
                  console.error('Failed to parse/send session:', e);
                }
              } else {
                console.log('‚ö† No session available to send');
                // Send null session response
                window.parent.postMessage({
                  type: 'SIDEDRAWER_SESSION_RESPONSE',
                  session: null
                }, '*');
              }
            }
          });
          
          console.log('‚úÖ Session bridge ready (localStorage only, no Zoho SDK needed)');
          
          // Helper function to check if parent window is ready for SDK communication
          const checkParentWindowReady = () => {
            try {
              // Check if we're in an iframe
              if (window.self === window.top) return true; // Standalone mode
              
              // Check if parent window is accessible
              if (!window.parent) return false;
              
              // Try to access parent (may throw in cross-origin scenarios)
              try {
                const test = window.parent.location;
                return true;
              } catch (e) {
                // Cross-origin - this is normal for externally hosted widgets
                // Parent window exists but we can't access location
                return true; // Assume ready if parent exists
              }
            } catch (error) {
              return false;
            }
          };
          
          // Helper function to test if SDK objects exist (DO NOT call SDK methods - they require PageLoad)
          // SDK methods MUST be called INSIDE PageLoad handler or AFTER PageLoad fires
          const testSDKReadiness = () => {
            // Only check if SDK objects exist, don't call methods
            // Calling getCurrentUser() before PageLoad causes "Parentwindow reference not found" error
            return !!(ZOHO?.CRM?.CONFIG?.getCurrentUser);
          };
          
          // Initialize Zoho SDK according to official documentation
          // For externally hosted widgets: init() may not resolve until PageLoad fires
          const isStandalone = window.self === window.top;
          
          // Check parent window readiness before SDK initialization
          if (!isStandalone) {
            const parentReady = checkParentWindowReady();
            console.log('[SideDrawer Widget] Parent window ready:', parentReady);
            if (!parentReady) {
              console.warn('[SideDrawer Widget] ‚ö†Ô∏è Parent window not ready, SDK may not work properly');
            }
          }
          
          if (!isStandalone && typeof ZOHO !== 'undefined' && ZOHO.embeddedApp) {
            try {
              // Create a promise that resolves when PageLoad fires (SDK readiness signal)
              let pageLoadResolve = null;
              const pageLoadPromise = new Promise((resolve) => {
                pageLoadResolve = resolve;
              });
              
              // Register PageLoad event listener FIRST (before init) as per Zoho docs
              // PageLoad event fires when SDK is ready for API calls
              // CRITICAL: Handler MUST be registered before init() is called
              console.log('[SideDrawer Widget] Registering PageLoad event handler...');
              ZOHO.embeddedApp.on("PageLoad", (data) => {
                console.log('[SideDrawer Widget] ‚úÖ PageLoad event fired - SDK is ready for API calls:', data);
                this.zohoInitialized = true;
                if (pageLoadResolve) {
                  pageLoadResolve();
                }
              });
              console.log('[SideDrawer Widget] ‚úÖ PageLoad handler registered');
              
              // Call init() WITHOUT awaiting (fire-and-forget)
              // For externally hosted widgets, init() may not resolve until PageLoad fires
              // PageLoad event is the signal that SDK is ready, not the init() promise
              console.log('[SideDrawer Widget] Calling ZOHO.embeddedApp.init() (fire-and-forget)...');
              ZOHO.embeddedApp.init().catch(err => {
                console.warn('[SideDrawer Widget] Init error (may be normal for externally hosted):', err.message);
              });
              
              // Wait for PageLoad event OR timeout after 10 seconds
              // PageLoad is the PRIMARY signal - SDK methods can only be called after PageLoad fires
              console.log('[SideDrawer Widget] Waiting for PageLoad event (SDK methods require PageLoad)...');
              try {
                // Create polling promise that checks SDK object existence and waits for PageLoad
                const pollSDKReadiness = async () => {
                  let attempts = 0;
                  const maxAttempts = 20; // 20 attempts * 500ms = 10 seconds
                  
                  while (attempts < maxAttempts) {
                    attempts++;
                    if (attempts % 4 === 0) {
                      console.log(`[SideDrawer Widget] Still waiting for PageLoad event... (${attempts * 500}ms elapsed)`);
                    }
                    
                    // Check if SDK objects exist (synchronous check, no method calls)
                    const objectsExist = testSDKReadiness();
                    if (objectsExist) {
                      // Objects exist, but we MUST wait for PageLoad before calling SDK methods
                      // Check if PageLoad already fired
                      if (this.zohoInitialized) {
                        console.log('[SideDrawer Widget] ‚úÖ PageLoad fired and SDK objects exist');
                        return; // PageLoad fired, we're ready
                      }
                      // Objects exist but PageLoad hasn't fired yet - wait a bit more
                      await new Promise(resolve => setTimeout(resolve, 500));
                      // Check again if PageLoad fired during the wait
                      if (this.zohoInitialized) {
                        console.log('[SideDrawer Widget] ‚úÖ PageLoad fired during wait');
                        return;
                      }
                    }
                    
                    // Wait before next attempt
                    await new Promise(resolve => setTimeout(resolve, 500));
                  }
                  
                  console.warn('[SideDrawer Widget] ‚ö†Ô∏è PageLoad timeout after 10 seconds');
                  // Proceed anyway - retry logic will handle it, but SDK calls may fail
                };
                
                // PageLoad promise is PRIMARY - it's the only reliable signal for SDK readiness
                await Promise.race([
                  pageLoadPromise.then(() => {
                    console.log('[SideDrawer Widget] ‚úÖ PageLoad event received - SDK is ready for API calls');
                  }),
                  pollSDKReadiness(),
                  new Promise((resolve) => setTimeout(() => {
                    console.warn('[SideDrawer Widget] ‚ö†Ô∏è Overall timeout after 10 seconds, proceeding anyway');
                    resolve();
                  }, 10000))
                ]);
                
                // Verify PageLoad fired before proceeding
                if (this.zohoInitialized) {
                  console.log('[SideDrawer Widget] ‚úÖ PageLoad confirmed - proceeding with SDK API calls');
                } else {
                  console.warn('[SideDrawer Widget] ‚ö†Ô∏è PageLoad did not fire - SDK API calls may fail');
                }
                
                console.log('[SideDrawer Widget] ‚úÖ SDK initialization check complete');
              } catch (error) {
                console.warn('[SideDrawer Widget] ‚ö†Ô∏è Error waiting for SDK readiness:', error);
                // Proceed anyway - retry logic in getCurrentUser() will handle it
              }
            } catch (error) {
              console.warn('[SideDrawer Widget] ‚ö†Ô∏è Error setting up Zoho SDK:', error);
              this.zohoInitialized = false;
            }
          } else if (isStandalone) {
            console.log('[SideDrawer Widget] Standalone mode - Zoho SDK not available');
          }
          
          try {
            // Set up message listener for OAuth popup callback
            window.addEventListener('message', async (event) => {
              console.log('üì® Parent received message:', event.data?.type || 'unknown');
              
              // Verify origin for security
              if (event.origin !== window.location.origin) {
                console.warn('‚ö† Ignoring message from different origin:', event.origin);
                return;
              }
              
              if (event.data && event.data.type === 'SIDEDRAWER_OAUTH_TOKENS') {
                console.log('‚úÖ Received OAuth tokens from popup');
                console.log('Has access_token:', !!event.data.tokens?.access_token);
                console.log('Has refresh_token:', !!event.data.tokens?.refresh_token);
                
                // Show processing message
                document.getElementById('app-content').innerHTML = `
                  <div class="loading">
                    <div class="spinner"></div>
                    <p>Saving authentication...</p>
                  </div>
                `;
                
                try {
                  // Save the tokens
                  await this.saveTokens(event.data.tokens);
                  console.log('‚úÖ Tokens saved successfully');
                  
                  // Show connected status
                  await this.checkConnection();
                } catch (error) {
                  console.error('‚ùå Failed to save tokens:', error);
                  this.showError(`Failed to save authentication: ${error.message}`);
                }
              } else if (event.data && event.data.type === 'SIDEDRAWER_OAUTH_ERROR') {
                console.error('‚ùå OAuth error from popup:', event.data.error);
                this.showError(`Authentication failed: ${event.data.error}`);
              }
            });

            // Initialize setup modal
            if (typeof window.SetupModal !== 'undefined') {
              this.setupModal = new window.SetupModal(this);
              window.setupModal = this.setupModal; // Make globally accessible
            }
            
            // Initialize account selection modal
            if (typeof window.AccountSelectionModal !== 'undefined') {
              this.accountSelectionModal = new window.AccountSelectionModal(this);
              window.accountSelectionModal = this.accountSelectionModal; // Make globally accessible
            }
            
            // SDK initialization is now handled above with PageLoad event
            // The zohoInitialized flag is set when PageLoad fires
            // loadZohoConfig() calls getCurrentUser() which REQUIRES PageLoad to have fired
            if (!isStandalone && typeof ZOHO !== 'undefined') {
              // Final verification - check if SDK methods are available
              if (ZOHO?.CRM?.CONFIG?.getCurrentUser) {
                console.log('[SideDrawer Widget] ‚úÖ SDK methods available');
              } else {
                console.warn('[SideDrawer Widget] ‚ö†Ô∏è SDK methods not yet available');
                console.warn('[SideDrawer Widget] ZOHO exists:', typeof ZOHO !== 'undefined');
                console.warn('[SideDrawer Widget] ZOHO.CRM exists:', typeof ZOHO?.CRM !== 'undefined');
                console.warn('[SideDrawer Widget] ZOHO.CRM.CONFIG exists:', typeof ZOHO?.CRM?.CONFIG !== 'undefined');
                console.warn('[SideDrawer Widget] getCurrentUser exists:', typeof ZOHO?.CRM?.CONFIG?.getCurrentUser === 'function');
              }
              
              // CRITICAL: Verify PageLoad fired before calling SDK methods
              // getCurrentUser() will fail with "Parentwindow reference not found" if called before PageLoad
              if (this.zohoInitialized) {
                console.log('[SideDrawer Widget] ‚úÖ PageLoad confirmed - safe to call SDK methods');
              } else {
                console.warn('[SideDrawer Widget] ‚ö†Ô∏è PageLoad did not fire - SDK API calls may fail');
                console.warn('[SideDrawer Widget] Proceeding anyway (retry logic in getCurrentUser() will handle failures)');
              }
            }
            
            // Load Zoho config and check permissions BEFORE initializing UI
            // This calls getCurrentUser() which requires PageLoad to have fired
            await this.loadZohoConfig();
            
            // Initialize after Zoho setup and permission check complete
            console.log('Proceeding with initialization (Zoho initialized:', this.zohoInitialized, ')');
            console.log('Permission status:', this.hasManageOrgPermission ? 'Admin' : 'Standard User');
            console.log('OAuth Redirect URI:', OAUTH_CONFIG.redirectUri);
            this.init();
          } catch (error) {
            console.error('Initialization error:', error);
          }
        }

        async loadZohoConfig() {
          try {
            // Check if we're in standalone mode (local development)
            // In Zoho, widget runs in iframe (window.self !== window.top)
            // When running locally (npm start), window.self === window.top
            const isStandalone = window.self === window.top;
            
            if (isStandalone) {
              // Bypass permission check in standalone mode for local testing
              this.hasManageOrgPermission = true;
              console.log('‚úì Standalone mode detected (local dev) - bypassing permission check (full access for testing)');
              
              // In standalone mode, check localStorage for credentials
              try {
                const storedConfig = localStorage.getItem('sd_widget_setup_config');
                if (storedConfig) {
                  const config = JSON.parse(storedConfig);
                  if (config && config.clientId) {
                    OAUTH_CONFIG.clientId = config.clientId;
                    OAUTH_CONFIG.redirectUri = config.redirectUri || OAUTH_CONFIG.redirectUri;
                    if (config.environment === 'production') {
                      OAUTH_CONFIG.authorizationEndpoint = 'https://auth.sidedrawer.com/authorize';
                      OAUTH_CONFIG.tokenEndpoint = 'https://auth.sidedrawer.com/oauth/token';
                      OAUTH_CONFIG.audience = 'https://user-api.sidedrawer.com';
                    }
                    console.log('‚úì Loaded credentials from localStorage (standalone mode)');
                    return;
                  }
                }
              } catch (e) {
                console.warn('[loadZohoConfig] Error loading from localStorage:', e);
              }
              
              // In standalone mode, skip Zoho API calls
              return;
            }
            
            // Check user permissions in Zoho environment
            try {
              if (window.SetupAPI && typeof window.SetupAPI.checkUserHasManageOrgPermission === 'function') {
                console.log('[loadZohoConfig] Checking user permissions...');
                this.hasManageOrgPermission = await window.SetupAPI.checkUserHasManageOrgPermission();
                console.log('‚úì Permission check result:', this.hasManageOrgPermission ? 'Admin (can configure)' : 'Standard User (read-only)');
                console.log('‚úì Permission stored in this.hasManageOrgPermission:', this.hasManageOrgPermission);
              } else {
                console.warn('‚ö†Ô∏è SetupAPI.checkUserHasManageOrgPermission not available');
                this.hasManageOrgPermission = false;
              }
            } catch (error) {
              console.error('[loadZohoConfig] Error checking permissions:', error);
              console.error('Error details:', error.stack);
              this.hasManageOrgPermission = false; // Default to false for security
            }
            
            // Priority 1: Try custom module first (via SetupAPI)
            try {
              if (window.SetupAPI && typeof window.SetupAPI.getCredentials === 'function') {
                // Add timeout to prevent hanging
                const credentialsPromise = window.SetupAPI.getCredentials();
                const timeoutPromise = new Promise((_, reject) =>
                  setTimeout(() => reject(new Error('Credentials load timeout')), 5000)
                );
                const credentials = await Promise.race([credentialsPromise, timeoutPromise]);
                
                if (credentials && credentials.clientId) {
                  console.log('‚úì Loaded credentials from:', credentials.source);
                  
                  // Set OAuth config from custom module
                  OAUTH_CONFIG.clientId = credentials.clientId;
                  
                  if (credentials.redirectUri) {
                    OAUTH_CONFIG.redirectUri = credentials.redirectUri;
                    console.log('‚úì Using redirect URI from custom module:', OAUTH_CONFIG.redirectUri);
                  }
                  
                  // Set environment endpoints
                  if (credentials.environment === 'production') {
                    OAUTH_CONFIG.authorizationEndpoint = 'https://auth.sidedrawer.com/authorize';
                    OAUTH_CONFIG.tokenEndpoint = 'https://auth.sidedrawer.com/oauth/token';
                    OAUTH_CONFIG.audience = 'https://user-api.sidedrawer.com';
                    console.log('‚úì Using PRODUCTION environment');
                  } else {
                    // Sandbox (default)
                    OAUTH_CONFIG.authorizationEndpoint = 'https://auth-sbx.sidedrawersbx.com/authorize';
                    OAUTH_CONFIG.tokenEndpoint = 'https://auth-sbx.sidedrawersbx.com/oauth/token';
                    OAUTH_CONFIG.audience = 'https://user-api-sbx.sidedrawersbx.com';
                    console.log('‚úì Using SANDBOX environment');
                  }
                  
                  return; // Successfully loaded from custom module
                }
              }
            } catch (error) {
              console.warn('[loadZohoConfig] Error loading from custom module:', error);
              // Continue to fallback
            }
            
            // Priority 2: Fallback to widget variables
            try {
              if (typeof ZOHO !== 'undefined' && ZOHO.CRM && ZOHO.CRM.CONFIG) {
                const config = await ZOHO.CRM.CONFIG.getVariables();
                
                if (config) {
                  console.log('‚úì Loaded Zoho widget variables (fallback):', Object.keys(config));
                  
                  // Redirect URI (REQUIRED in production)
                  if (config.redirect_uri && config.redirect_uri.trim()) {
                    OAUTH_CONFIG.redirectUri = config.redirect_uri.trim();
                    console.log('‚úì Using configured redirect URI:', OAUTH_CONFIG.redirectUri);
                  } else {
                    console.warn('‚ö† No redirect URI configured - using auto-detection (may not work behind proxies)');
                    console.log('Current URL:', OAUTH_CONFIG.redirectUri);
                  }
                  
                  // Client ID (can also come from URL params)
                  if (config.client_id && config.client_id.trim()) {
                    OAUTH_CONFIG.clientId = config.client_id.trim();
                    console.log('‚úì Client ID loaded from Zoho config');
                  }
                  
                  // Environment (REQUIRED)
                  if (config.environment === 'production') {
                    OAUTH_CONFIG.authorizationEndpoint = 'https://auth.sidedrawer.com/authorize';
                    OAUTH_CONFIG.tokenEndpoint = 'https://auth.sidedrawer.com/oauth/token';
                    OAUTH_CONFIG.audience = 'https://user-api.sidedrawer.com';
                    console.log('‚úì Using PRODUCTION environment');
                  } else if (config.environment === 'sandbox') {
                    // Already set to sandbox by default
                    console.log('‚úì Using SANDBOX environment');
                  } else {
                    console.warn('‚ö† No environment configured - using sandbox (default)');
                  }
                } else {
                  console.warn('‚ö† No Zoho configuration found - using defaults (development mode)');
                }
              }
            } catch (error) {
              console.warn('‚ö† Could not load Zoho widget variables:', error.message);
            }
          } catch (error) {
            console.warn('‚ö† Could not load Zoho config, using defaults (development mode):', error.message);
          }
        }

        // Simple localStorage-only session management
        async setZohoSession(data) {
          localStorage.setItem(ZOHO_SESSION_KEY, JSON.stringify(data));
          console.log('‚úì Stored session in localStorage');
          return true;
        }

        async getZohoSession() {
          const data = localStorage.getItem(ZOHO_SESSION_KEY);
          return data ? JSON.parse(data) : null;
        }

        async clearZohoSession() {
          localStorage.removeItem(ZOHO_SESSION_KEY);
          console.log('‚úì Cleared session from localStorage');
        }

        async init() {
          // Check if we're returning from OAuth redirect
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get('code');
          const error = urlParams.get('error');

          // Check if we're in a popup window opened for OAuth
          const isPopup = window.opener && !window.opener.closed;

          if (error) {
            if (isPopup) {
              // Close popup and let parent handle error
              window.close();
            } else {
              this.showError(`Authentication error: ${error}`);
              this.cleanupOAuthState();
            }
            return;
          }

          if (code) {
            if (isPopup) {
              // We're in the OAuth popup - exchange code for tokens and pass to parent
              console.log('üîê OAuth popup: Received authorization code');
              console.log('Code:', code.substring(0, 20) + '...');
              
              // Show loading in popup
              document.getElementById('app-content').innerHTML = `
                <div class="loading">
                  <div class="spinner"></div>
                  <p>Completing authentication...</p>
                  <p class="text-small-gray mt-10">This window will close automatically...</p>
                </div>
              `;
              
              try {
                // IMPORTANT: Try state parameter FIRST (most reliable, can't be stale)
                let codeVerifier = null;
                const state = urlParams.get('state');
                console.log('üîç State parameter from URL:', state ? state.substring(0, 50) + '...' : 'NOT FOUND');
                
                if (state) {
                  try {
                    const decoded = atob(state);
                    console.log('üîç Decoded state:', decoded);
                    const stateData = JSON.parse(decoded);
                    console.log('üîç Parsed state data:', stateData);
                    codeVerifier = stateData.verifier;
                    console.log('‚úÖ Code verifier from state parameter:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                  } catch (e) {
                    console.warn('‚ö† Could not parse state parameter:', e);
                    console.error('State parsing error details:', e.stack);
                  }
                }
                
                // Fallback to localStorage only if state failed
                if (!codeVerifier) {
                  codeVerifier = localStorage.getItem(STORAGE_KEYS.codeVerifier);
                  console.log('Code verifier from localStorage:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                }
                
                // Last resort: sessionStorage
                if (!codeVerifier) {
                  codeVerifier = sessionStorage.getItem(STORAGE_KEYS.codeVerifier);
                  console.log('Code verifier from sessionStorage:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                }
                
                if (!codeVerifier) {
                  throw new Error('Code verifier not found in localStorage, sessionStorage, or state parameter');
                }
                
                console.log('‚úì Code verifier found, exchanging code for tokens...');
                console.log('Code verifier length:', codeVerifier.length);
                console.log('Code verifier sample:', codeVerifier.substring(0, 20) + '...' + codeVerifier.substring(codeVerifier.length - 10));
                console.log('Token endpoint:', OAUTH_CONFIG.tokenEndpoint);
                console.log('Client ID:', OAUTH_CONFIG.clientId);
                console.log('Redirect URI:', OAUTH_CONFIG.redirectUri);

                const tokenRequestBody = {
                  grant_type: 'authorization_code',
                  client_id: OAUTH_CONFIG.clientId,
                  code: code,
                  code_verifier: codeVerifier,
                  redirect_uri: OAUTH_CONFIG.redirectUri,
                  audience: OAUTH_CONFIG.audience
                };

                const tokenResponse = await fetch(OAUTH_CONFIG.tokenEndpoint, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(tokenRequestBody)
                });

                console.log('Token response status:', tokenResponse.status, tokenResponse.statusText);

                if (!tokenResponse.ok) {
                  const responseText = await tokenResponse.text();
                  console.error('‚ùå Token exchange error response (raw):', responseText);
                  let errorData;
                  try {
                    errorData = JSON.parse(responseText);
                  } catch (e) {
                    errorData = { error: 'Parse error', raw: responseText };
                  }
                  console.error('‚ùå Token exchange error (parsed):', errorData);
                  throw new Error(errorData.error_description || errorData.error || `Token exchange failed: ${tokenResponse.status}`);
                }

                const tokenData = await tokenResponse.json();
                console.log('‚úÖ Token exchange successful!');
                console.log('Has access_token:', !!tokenData.access_token);
                console.log('Has refresh_token:', !!tokenData.refresh_token);
                console.log('Expires in:', tokenData.expires_in);
                
                // Show success message in popup
                document.getElementById('app-content').innerHTML = `
                  <div class="success-message">
                    ‚úì Authentication successful!
                    <br><small>Closing window...</small>
                  </div>
                `;
                
                // Send tokens to parent window
                if (window.opener && !window.opener.closed) {
                  console.log('Sending tokens to parent window...');
                  window.opener.postMessage({ 
                    type: 'SIDEDRAWER_OAUTH_TOKENS',
                    tokens: tokenData
                  }, window.location.origin);
                  console.log('‚úÖ Tokens sent to parent');
                } else {
                  console.warn('‚ö† Parent window not available');
                }
                
                // Clean up and close
                localStorage.removeItem(STORAGE_KEYS.codeVerifier);
                sessionStorage.removeItem(STORAGE_KEYS.codeVerifier);
                setTimeout(() => {
                  console.log('Closing popup...');
                  window.close();
                }, 1000);
                
              } catch (error) {
                console.error('‚ùå OAuth popup error:', error);
                console.error('Error details:', error.stack);
                
                // Show error message in popup
                document.getElementById('app-content').innerHTML = `
                  <div class="error-message">
                    ‚úó Authentication failed
                    <br><small>${error.message}</small>
                    <br><small class="mt-10 block">Check browser console for details. Window will close in 5 seconds...</small>
                  </div>
                `;
                
                // Send error to parent
                if (window.opener && !window.opener.closed) {
                  window.opener.postMessage({ 
                    type: 'SIDEDRAWER_OAUTH_ERROR',
                    error: error.message
                  }, window.location.origin);
                }
                setTimeout(() => window.close(), 5000);
              }
              return;
            } else {
              // Normal flow (not in popup) - handle callback directly
              await this.handleOAuthCallback(code);
              return;
            }
          }

          // Check existing token
          try {
            // Add timeout to prevent hanging
            const checkPromise = this.checkConnection();
            const timeoutPromise = new Promise((_, reject) =>
              setTimeout(() => reject(new Error('checkConnection timeout')), 5000)
            );
            
            const hasSession = await Promise.race([checkPromise, timeoutPromise]);
            if (!hasSession) {
              // No session - checkConnection() should have already shown appropriate UI
              // (disconnected status or account selection)
              console.log('No session found, UI should be displayed by checkConnection()');
            }
          } catch (error) {
            console.error('Error in checkConnection:', error);
            // Fallback: show disconnected status on any error
            console.log('‚ö†Ô∏è Falling back to showDisconnectedStatus() due to error or timeout');
            this.showDisconnectedStatus();
          }
        }

        async checkConnection() {
          try {
            // Try to get existing session
            const session = await this.getZohoSession();
            const refreshToken = await this.getRefreshToken();
          
          // Check if session exists and token is valid
          if (session && session.accessToken && !this.isTokenExpired(session.expiresAt)) {
            // Valid session exists - check if credentials are configured
            console.log('‚úì Valid session found');
            
            // Check if credentials exist in custom module or widget variables
            let credentialsExist = false;
            try {
              // In standalone mode, skip API calls that might hang
              const isStandalone = window.self === window.top;
              if (!isStandalone && window.SetupAPI && typeof window.SetupAPI.getCredentials === 'function') {
                // Add timeout to prevent hanging (safety measure)
                const credentialsPromise = window.SetupAPI.getCredentials();
                const timeoutPromise = new Promise((_, reject) => 
                  setTimeout(() => reject(new Error('Credentials check timeout')), 5000)
                );
                const credentials = await Promise.race([credentialsPromise, timeoutPromise]);
                credentialsExist = !!(credentials && credentials.clientId);
              } else if (isStandalone) {
                // In standalone mode, check localStorage or URL params
                const storedConfig = localStorage.getItem('sd_widget_setup_config');
                if (storedConfig) {
                  try {
                    const config = JSON.parse(storedConfig);
                    credentialsExist = !!(config && config.clientId);
                  } catch (e) {
                    // Ignore parse errors
                  }
                }
                // Also check OAUTH_CONFIG (may be set from URL params)
                if (!credentialsExist && OAUTH_CONFIG.clientId) {
                  credentialsExist = true;
                }
              } else if (OAUTH_CONFIG.clientId) {
                credentialsExist = true;
              }
            } catch (error) {
              console.warn('[checkConnection] Error checking credentials:', error);
              // Continue with credentialsExist = false
            }
            
            if (!credentialsExist) {
              // No credentials configured - show account selection: create new or use existing
              // Both options converge at setup modal
              // BUT: In standalone mode with no credentials, just show disconnected status directly
              const isStandalone = window.self === window.top;
              if (isStandalone) {
                // In standalone mode without credentials, show disconnected status directly
                // (account selection requires credentials to be meaningful)
                console.log('‚ö†Ô∏è Standalone mode: No credentials configured, showing disconnected status');
                this.showDisconnectedStatus();
                return false;
              } else {
                // In Zoho environment, show account selection
                try {
                  await this.showAccountSelection();
                } catch (error) {
                  console.error('[checkConnection] Error showing account selection:', error);
                  // Fallback to disconnected status
                  this.showDisconnectedStatus();
                }
                return false;
              }
            }
            
            // Credentials exist - check if tenant exists (only if not standalone to avoid API calls)
            const isStandalone = window.self === window.top;
            if (!isStandalone) {
              try {
                const hasTenant = await this.checkTenantExists();
                if (!hasTenant) {
                  // Credentials configured but no tenant - show account selection
                  try {
                    await this.showAccountSelection();
                  } catch (error) {
                    console.error('[checkConnection] Error showing account selection:', error);
                    // Fallback to disconnected status
                    this.showDisconnectedStatus();
                  }
                  return false;
                }
              } catch (error) {
                console.warn('[checkConnection] Error checking tenant:', error);
                // Continue - show connected status anyway
              }
            }
            
            this.showConnectedStatus();
            return true;
          } else if (session && session.accessToken && this.isTokenExpired(session.expiresAt)) {
            // Session exists but token is EXPIRED
            // DON'T refresh immediately on page load (F5) - let ensureValidSession() handle it when needed
            // This prevents wasting silver bullets with invalid refresh tokens
            console.log('‚ö†Ô∏è Expired session detected on page load');
            console.log('  Expires at:', session.expiresAt ? new Date(parseInt(session.expiresAt)).toISOString() : 'N/A');
            console.log('  Current time:', new Date().toISOString());
            console.log('  Refresh token available:', refreshToken ? 'YES' : 'NO');
            console.log('  Session keys:', session ? Object.keys(session) : []);
            console.log('  Note: Refresh will happen automatically when needed via ensureValidSession()');
            
            if (refreshToken) {
              // Show connected status - refresh will happen when API calls are made
              this.showConnectedStatus();
              return true;
            } else {
              console.warn('‚ö†Ô∏è Expired session found but no refresh token available');
              console.warn('‚ö†Ô∏è This session was created before refresh token storage was added');
              console.warn('‚ö†Ô∏è You need to re-authenticate to get a refresh token');
              
              // Show helpful error message
              document.getElementById('app-content').innerHTML = `
                <div class="status-card error">
                  <div class="status-indicator">
                    <div class="status-dot error"></div>
                    <span class="status-text">Session Expired - Re-authentication Required</span>
                  </div>
                  <p class="status-info-text">
                    Your session expired and cannot be refreshed automatically because it was created before refresh token storage was implemented.
                  </p>
                  <p class="status-info-text">
                    Please click "Connect to SideDrawer" below to re-authenticate. Your new session will include refresh token support.
                  </p>
                </div>
                <button class="btn btn-success mt-20" onclick="auth.startOAuthFlow()">Connect to SideDrawer</button>
              `;
            }
          } else if (refreshToken) {
            // No session but have refresh token - try silent refresh
            // BUT ONLY if clientId is configured
            if (!OAUTH_CONFIG.clientId) {
              console.log('‚ö†Ô∏è Refresh token exists but no Client ID configured - cannot refresh');
              this.showDisconnectedStatus();
              return false;
            }
            
            console.log('üîÑ No session found, but refresh token exists - attempting refresh...');
            document.getElementById('app-content').innerHTML = `
              <div class="loading">
                <div class="spinner"></div>
                <p>Refreshing connection...</p>
              </div>
            `;
            await this.refreshAccessToken();
          } else {
            // No valid session or refresh token
            console.log('‚ö†Ô∏è No session or refresh token found');
            
            // Show disconnected status with "Create new tenant" button
            this.showDisconnectedStatus();
            return false;
          }
          } catch (error) {
            console.error('[checkConnection] Unexpected error:', error);
            // Always show disconnected status as fallback
            this.showDisconnectedStatus();
            return false;
          }
        }

        startPeriodicTokenRefresh() {
          // REMOVED: Periodic refresh wastes silver bullets
          // Token refresh is now handled reactively by ensureValidSession() when actually needed
          // This prevents unnecessary refresh attempts that waste refresh tokens
        }

        async showConnectedStatus() {
          // Periodic refresh removed - refresh happens reactively when needed via ensureValidSession()
          
          const session = await this.getZohoSession();
          const expiryDate = session ? new Date(parseInt(session.expiresAt)) : new Date();
          const hasRefreshToken = !!(await this.getRefreshToken());
          
          document.getElementById('app-content').innerHTML = `
            <div class="status-card connected">
              <div class="status-indicator">
                <div class="status-dot connected"></div>
                <span class="status-text">Connected to SideDrawer</span>
              </div>
              <p class="status-info-text">Your integration is active and ready to use.</p>
            </div>

            <div class="status-info-box">
              <p class="status-info-item"><strong class="status-info-label">Status:</strong> Authenticated</p>
              <p class="status-info-item"><strong class="status-info-label">Storage:</strong> ${this.zohoInitialized ? 'Zoho Session (shared across widgets)' : 'localStorage (fallback)'}</p>
              <p class="status-info-item"><strong class="status-info-label">Token Expires:</strong> ${expiryDate.toLocaleString()}</p>
              <p class="status-info-item"><strong class="status-info-label">Silent Refresh:</strong> ${hasRefreshToken ? 'Enabled' : 'Disabled'}</p>
            </div>

            <div class="button-group">
              <button class="btn" onclick="auth.disconnect()">Disconnect</button>
              <button class="btn btn-success" onclick="auth.testConnection()">Test Connection</button>
              ${this.hasManageOrgPermission ? `
                <button class="btn btn-primary" onclick="auth.showTenantCreationFlow()">Create New Tenant</button>
                <button class="btn btn-outline" onclick="auth.showSetupModal()">‚öôÔ∏è Setup</button>
              ` : ''}
            </div>

            <div id="test-result"></div>
          `;
        }

        showDisconnectedStatus() {
          document.getElementById('app-content').innerHTML = `
            <div class="status-card">
              <div class="status-indicator">
                <div class="status-dot"></div>
                <span class="status-text">Not Connected</span>
              </div>
              <p class="text-muted-sm">Connect your SideDrawer account to enable the integration.</p>
            </div>

            <div class="info-section">
              <p><strong>What is SideDrawer?</strong></p>
              <p>SideDrawer is a secure document storage and sharing platform designed for financial advisors and their clients.</p>
              <br>
              <p><strong>This integration allows you to:</strong></p>
              <ul class="list-item-spaced">
                <li>Access SideDrawer documents directly from Zoho CRM</li>
                <li>Share content with clients through SideDrawer</li>
                <li>Manage client documents securely</li>
              </ul>
            </div>

            <button class="btn btn-success" onclick="auth.startOAuthFlow()">Connect to SideDrawer</button>
            ${this.hasManageOrgPermission || window.self === window.top ? `
              <button class="btn btn-outline mt-10" onclick="auth.showTenantCreationFlow()">Create New Tenant</button>
              <button class="btn btn-outline mt-10" onclick="auth.showSetupModal()">‚öôÔ∏è Setup</button>
              <button class="btn btn-outline mt-10" onclick="auth.resetConfiguration()" style="color: #dc3545;">
                üîÑ Reset Configuration
              </button>
            ` : ''}
          `;
        }

        showError(message, showDisconnect = false) {
          const disconnectButton = showDisconnect ? `
            <button class="btn" onclick="auth.disconnect()" style="background: #dc3545; margin-left: 10px;">
              Disconnect & Re-authenticate
            </button>
          ` : '';
          
          document.getElementById('app-content').innerHTML = `
            <div class="status-card error">
              <div class="status-indicator">
                <div class="status-dot error"></div>
                <span class="status-text">Connection Error</span>
              </div>
              <div class="error-message">
                ${message}
              </div>
            </div>

            <button class="btn" onclick="auth.checkConnection()">Try Again</button>
            ${disconnectButton}
          `;
        }

        async checkTenantExists() {
          // In standalone mode, skip tenant check to avoid hanging
          const isStandalone = window.self === window.top;
          if (isStandalone) {
            console.log('[checkTenantExists] Standalone mode - skipping tenant check');
            return false; // Assume no tenant in standalone mode
          }
          
          try {
            const token = await this.getAccessToken();
            if (!token) return false;

            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const tenantApi = isSandbox
              ? 'https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/tenant/shared'
              : 'https://tenants-gateway-api.sidedrawer.com/api/v1/tenants/tenant/shared';

            // Add timeout to prevent hanging
            const fetchPromise = fetch(tenantApi, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });
            
            const timeoutPromise = new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Tenant check timeout')), 5000)
            );
            
            const response = await Promise.race([fetchPromise, timeoutPromise]);

            if (response.ok) {
              const tenants = await response.json();
              return tenants && tenants.length > 0;
            }
            return false;
          } catch (error) {
            console.error('‚ùå Error checking tenant:', error);
            return false;
          }
        }

        async showSetupModal(options = {}) {
          if (!this.setupModal) {
            if (typeof window.SetupModal !== 'undefined') {
              this.setupModal = new window.SetupModal(this);
              window.setupModal = this.setupModal;
            } else {
              this.showError('Setup modal is not available. Please refresh the page.');
              return;
            }
          }
          await this.setupModal.open(options);
        }

        async showAccountSelection() {
          try {
            if (!this.accountSelectionModal) {
              if (typeof window.AccountSelectionModal !== 'undefined') {
                this.accountSelectionModal = new window.AccountSelectionModal(this);
                window.accountSelectionModal = this.accountSelectionModal;
              } else {
                console.error('[Account Selection] Modal class not available');
                // Fallback: show disconnected status instead
                this.showDisconnectedStatus();
                return;
              }
            }
            await this.accountSelectionModal.open();
          } catch (error) {
            console.error('[Account Selection] Error opening modal:', error);
            // Fallback: show disconnected status on error
            this.showDisconnectedStatus();
          }
        }

        async showTenantCreationWizard() {
          // Directly show tenant creation wizard (for logged-in users)
          const session = await this.getZohoSession();
          const token = await this.getAccessToken();
          
          if (!session || !token) {
            this.showError('You must be logged in to create a tenant.');
            return;
          }
          
          // Use existing tenant creation flow
          await this.showTenantCreationFlowDirect();
        }

        async showTenantCreationFlowDirect() {
          // Direct tenant creation wizard (bypasses account selection)
          const session = await this.getZohoSession();
          const token = await this.getAccessToken();
          
          // Ensure tenant-wizard container exists
          let wizardContainer = document.getElementById('tenant-wizard');
          if (!wizardContainer) {
            wizardContainer = document.createElement('div');
            wizardContainer.id = 'tenant-wizard';
            wizardContainer.style.display = 'none';
            const container = document.querySelector('.container');
            if (container) {
              container.appendChild(wizardContainer);
            } else {
              document.body.appendChild(wizardContainer);
            }
          }
          
          // Hide main content
          const appContent = document.getElementById('app-content');
          if (appContent) {
            appContent.style.display = 'none';
          }
          
          // Show wizard container
          wizardContainer.style.display = 'block';
          
          // Initialize tenant wizard with credentials
          if (typeof window.tenantWizardWithCredentials !== 'undefined' && window.tenantWizardWithCredentials) {
            try {
              await window.tenantWizardWithCredentials.init(token);
              return;
            } catch (error) {
              const dict = window.tenantWizardWithCredentials?.state?.dictionary || {};
              this.showError(dict.globalparams_error || 'Failed to initialize tenant creation wizard: ' + error.message);
              return;
            }
          }
          
          this.showError('Tenant creation wizard is not available. Please refresh the page.');
        }

        async showTenantCreationFlow() {
          // Check if we're in standalone mode (local development)
          const isStandalone = window.self === window.top;
          
          // Check permissions first (bypass in standalone mode)
          if (!isStandalone && !this.hasManageOrgPermission) {
            this.showError('Permission denied: Only users with "Manage Organization" rights can create tenants.');
            return;
          }
          
          if (isStandalone) {
            console.log('‚úì Standalone mode - bypassing permission check for tenant creation');
          }
          
          const session = await this.getZohoSession();
          const token = await this.getAccessToken();
          
          // If logged in, show account selection modal
          // If not logged in, show tenant creation wizard directly
          if (session && token) {
            // Logged in - show account selection (both options converge at setup modal)
            await this.showAccountSelection();
          } else {
            // Not logged in - show tenant creation wizard directly
            // After tenant creation, setup modal will open (converges)
            await this.showTenantCreationFlowDirect();
          }
        }

        async startOAuthFlow() {
          try {
            // Check if we're in standalone mode (local development)
            const isStandalone = window.self === window.top;
            
            // Validate configuration
            if (!OAUTH_CONFIG.clientId) {
              // If no OAuth config, check if user is admin OR in standalone mode
              if (isStandalone || this.hasManageOrgPermission) {
                // Admin or standalone mode can create tenant to set up credentials
                if (isStandalone) {
                  console.log('‚úì Standalone mode - allowing tenant creation for testing');
                }
                await this.showTenantCreationFlow();
              } else {
                // Non-admin users need admin to configure credentials first
                this.showError('Widget credentials are not configured. Please contact your administrator to set up the SideDrawer integration.');
              }
              return;
            }
            
            // Generate PKCE code verifier and challenge
            const codeVerifier = this.generateCodeVerifier();
            const codeChallenge = await this.generateCodeChallenge(codeVerifier);

            // Store code verifier in BOTH localStorage and sessionStorage for redundancy
            localStorage.setItem(STORAGE_KEYS.codeVerifier, codeVerifier);
            sessionStorage.setItem(STORAGE_KEYS.codeVerifier, codeVerifier);
            console.log('‚úì Code verifier stored:', codeVerifier.substring(0, 10) + '...');
            console.log('‚úì Code verifier length:', codeVerifier.length);

            // Build authorization URL with state containing code verifier for fallback
            const stateObj = {
              random: this.generateRandomString(16),
              verifier: codeVerifier
            };
            const state = JSON.stringify(stateObj);
            const encodedState = btoa(state);
            
            const authUrl = new URL(OAUTH_CONFIG.authorizationEndpoint);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('client_id', OAUTH_CONFIG.clientId);
            authUrl.searchParams.append('redirect_uri', OAUTH_CONFIG.redirectUri);
            authUrl.searchParams.append('scope', OAUTH_CONFIG.scope);
            authUrl.searchParams.append('audience', OAUTH_CONFIG.audience);
            authUrl.searchParams.append('code_challenge', codeChallenge);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('state', encodedState);

            // Check if we're running inside an iframe (Zoho)
            const isInIframe = window.self !== window.top;

            if (isInIframe) {
              // Open popup window for OAuth (works in Zoho iframe)
              const width = 600;
              const height = 700;
              const left = (screen.width - width) / 2;
              const top = (screen.height - height) / 2;
              
              const popupUrl = authUrl.toString();
              
              const popup = window.open(
                popupUrl,
                'SideDrawer OAuth',
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
              );

              if (!popup) {
                throw new Error('Popup blocked! Please allow popups for this site and try again.');
              }

              // Show waiting status
              document.getElementById('app-content').innerHTML = `
                <div class="status-card">
                  <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span class="status-text">Authenticating...</span>
                  </div>
                  <p class="auth-info-text">Please complete the login in the popup window.</p>
                  <p class="auth-info-text-small">
                    Don't see the popup? Check if your browser blocked it and allow popups for this site.
                  </p>
                </div>
              `;

              // Poll for popup close or callback
              const pollInterval = setInterval(() => {
                if (popup.closed) {
                  clearInterval(pollInterval);
                  console.log('Popup closed - checking for auth completion');
                  // Check if we got redirected back with a code
                  setTimeout(() => this.checkConnection(), 500);
                }
              }, 500);

            } else {
              console.log('Not in iframe - using direct redirect');
              // Not in iframe (localhost testing) - use direct redirect
              window.location.href = authUrl.toString();
            }

          } catch (error) {
            console.error('OAuth flow error:', error);
            this.showError(`Failed to start authentication: ${error.message}`);
          }
        }

        async handleOAuthCallback(code) {
          document.getElementById('app-content').innerHTML = `
            <div class="loading">
              <div class="spinner"></div>
              <p>Completing authentication...</p>
            </div>
          `;

          try {
            const codeVerifier = localStorage.getItem(STORAGE_KEYS.codeVerifier);
            
            if (!codeVerifier) {
              throw new Error('Code verifier not found. Please try again.');
            }

            // Exchange code for token (PKCE - no client_secret)
            const tokenRequestBody = {
              grant_type: 'authorization_code',
              client_id: OAUTH_CONFIG.clientId,
              code: code,
              code_verifier: codeVerifier,
              redirect_uri: OAUTH_CONFIG.redirectUri,
              audience: OAUTH_CONFIG.audience
            };
            
            const tokenResponse = await fetch(OAUTH_CONFIG.tokenEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(tokenRequestBody)
            });

            if (!tokenResponse.ok) {
              const errorData = await tokenResponse.json();
              throw new Error(errorData.error_description || 'Token exchange failed');
            }

            const tokenData = await tokenResponse.json();
            
            // Store tokens
            this.saveTokens(tokenData);
            this.cleanupOAuthState();

            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);

            // Show success
            document.getElementById('app-content').innerHTML = `
              <div class="success-message">
                ‚úì Successfully connected to SideDrawer!
              </div>
            `;

            // Reload to show connected status
            setTimeout(() => this.checkConnection(), 1500);

          } catch (error) {
            console.error('Token exchange error:', error);
            this.showError(`Authentication failed: ${error.message}`);
            this.cleanupOAuthState();
          }
        }

        async refreshAccessToken() {
          // Validate clientId is configured before attempting refresh
          if (!OAUTH_CONFIG.clientId) {
            console.error('‚ùå Cannot refresh token: Client ID not configured');
            this.showDisconnectedStatus();
            return;
          }
          
          const refreshToken = await this.getRefreshToken();
          
          if (!refreshToken) {
            console.error('‚ùå No refresh token available for refresh');
            // Last resort: check session object directly
            const session = await this.getZohoSession();
            if (session && session.refreshToken) {
              console.log('üîÑ Found refresh token in session object, using it...');
              // Use session.refreshToken directly
              const tokenToUse = session.refreshToken;
              // Continue with refresh using this token
              try {
                console.log('üîÑ Refreshing access token...');
                const refreshRequestBody = {
                  grant_type: 'refresh_token',
                  client_id: OAUTH_CONFIG.clientId,
                  refresh_token: tokenToUse,
                  audience: OAUTH_CONFIG.audience,
                  scope: OAUTH_CONFIG.scope  // CRITICAL: Include scope to get new refresh token with rotation enabled
                };
                
                const fetchPromise = fetch(OAUTH_CONFIG.tokenEndpoint, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(refreshRequestBody)
                });
                
                const timeoutPromise = new Promise((_, reject) =>
                  setTimeout(() => reject(new Error('Token refresh timeout')), 10000)
                );
                
                const response = await Promise.race([fetchPromise, timeoutPromise]);

                if (!response.ok) {
                  const errorText = await response.text();
                  console.error('‚ùå Token refresh failed:', response.status, errorText);
                  
                    
                  throw new Error(`Token refresh failed: ${response.status}`);
                }

                const tokenData = await response.json();
                console.log('‚úÖ Token refresh successful!');
                console.log('  New access token length:', tokenData.access_token?.length || 0);
                console.log('  Expires in:', tokenData.expires_in, 'seconds');
                console.log('  New refresh token provided:', !!tokenData.refresh_token);
                if (tokenData.refresh_token) {
                  console.log('  üîÑ ROTATION: New refresh token received, old token is now invalid');
                  console.log('  New refresh token preview:', tokenData.refresh_token.substring(0, 20) + '...');
                }
                this.saveTokens(tokenData);
                this.showConnectedStatus();
                return;
              } catch (error) {
                console.error('‚ùå Token refresh error:', error);
                this.showError(`Failed to refresh session: ${error.message}`, true);
                return;
              }
            }
            this.showDisconnectedStatus();
            return;
          }

          try {
            console.log('üîÑ Refreshing access token...');
            console.log('  Token endpoint:', OAUTH_CONFIG.tokenEndpoint);
            console.log('  Client ID:', OAUTH_CONFIG.clientId);
            console.log('  Refresh token:', refreshToken.substring(0, 20) + '...');
            
            const refreshRequestBody = {
              grant_type: 'refresh_token',
              client_id: OAUTH_CONFIG.clientId,
              refresh_token: refreshToken,
              audience: OAUTH_CONFIG.audience,
              scope: OAUTH_CONFIG.scope  // CRITICAL: Include scope to get new refresh token with rotation enabled
            };
            
            const fetchPromise = fetch(OAUTH_CONFIG.tokenEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(refreshRequestBody)
            });
            
            const timeoutPromise = new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Token refresh timeout')), 10000)
            );
            
            const response = await Promise.race([fetchPromise, timeoutPromise]);

            if (!response.ok) {
              const errorText = await response.text();
              console.error('‚ùå Token refresh failed:', response.status, errorText);
              
              // Log the actual request being made for debugging
              console.log('üîç Debugging refresh request:');
              console.log('   Endpoint:', OAUTH_CONFIG.tokenEndpoint);
              console.log('   Client ID:', OAUTH_CONFIG.clientId);
              console.log('   Refresh token (full):', refreshToken);
              console.log('   Audience:', OAUTH_CONFIG.audience);
              console.log('   Request body:', JSON.stringify(refreshRequestBody, null, 2));
              
              throw new Error(`Token refresh failed: ${response.status}`);
            }

            const tokenData = await response.json();
            console.log('‚úÖ Token refresh successful!');
            console.log('  New access token length:', tokenData.access_token?.length || 0);
            console.log('  Expires in:', tokenData.expires_in, 'seconds');
            console.log('  New refresh token provided:', !!tokenData.refresh_token);
            if (tokenData.refresh_token) {
              console.log('  üîÑ ROTATION: New refresh token received, old token is now invalid');
              console.log('  New refresh token preview:', tokenData.refresh_token.substring(0, 20) + '...');
            } else {
              console.warn('  ‚ö†Ô∏è WARNING: No new refresh token in response - rotation may not be working!');
            }
            
            this.saveTokens(tokenData);
            this.showConnectedStatus();

          } catch (error) {
            console.error('‚ùå Token refresh error:', error);
            console.error('Error details:', error.stack);
            // Show disconnect option since refresh token is likely invalid
            this.showError(`Failed to refresh session: ${error.message}`, true);
            // CRITICAL: Re-throw error so caller knows refresh failed
            throw error;
          }
        }

        async testConnection() {
          const resultDiv = document.getElementById('test-result');
          resultDiv.innerHTML = `
            <div class="loading loading-padded">
              <div class="spinner"></div>
              <p>Testing connection...</p>
            </div>
          `;

          try {
            const token = await this.getAccessToken();
            
            // Test API call to SideDrawer tenant endpoint
            const response = await fetch('https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/tenant/shared', {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });

            if (response.ok) {
              const data = await response.json();
              
              if (data && data.length > 0) {
                const tenant = data[0];
                const tenantInfo = { 
                  tenantId: tenant.id || "", 
                  brandCode: tenant.defaultBrandCode || "", 
                  region: tenant.region || "" 
                };
                
                resultDiv.innerHTML = `
                  <div class="success-message">
                    ‚úì Connection test successful!
                  </div>
                  <div class="info-section info-section-spaced">
                    <strong class="info-section-title">Tenant Information:</strong>
                    <p><strong>Tenant ID:</strong> ${tenantInfo.tenantId}</p>
                    <p><strong>Brand Code:</strong> ${tenantInfo.brandCode}</p>
                    <p><strong>Region:</strong> ${tenantInfo.region}</p>
                  </div>
                  <div class="token-info token-info-spaced">
                    <strong class="token-info-title">Access Token:</strong>
                    <code class="code-block">${token}</code>
                    <button class="btn btn-small" onclick="navigator.clipboard.writeText('${token}').then(() => alert('Token copied to clipboard!'))">üìã Copy Token</button>
                  </div>
                `;
              } else {
                throw new Error('No tenant data returned');
              }
            } else {
              const errorText = await response.text().catch(() => '');
              throw new Error(`API returned ${response.status}: ${errorText}`);
            }

          } catch (error) {
            console.error('Connection test error:', error);
            resultDiv.innerHTML = `
              <div class="error-message">
                ‚úó Connection test failed: ${error.message}
              </div>
            `;
          }
        }

        async disconnect() {
          console.log('üîì Disconnecting from SideDrawer...');
          
          // Clear periodic refresh interval
          if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
            console.log('‚úì Periodic refresh stopped');
          }
          
          // Clear Zoho session
          await this.clearZohoSession();
          
          // Clear refresh token from localStorage
          localStorage.removeItem(STORAGE_KEYS.refreshToken);
          
          // Clear all Auth0 cookies (including sidedrawer_refresh_token)
          this.clearAllCookies();
          
          // Clear all localStorage items related to SideDrawer and Auth0
          Object.keys(localStorage).forEach(key => {
            if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
              localStorage.removeItem(key);
            }
          });
          
          console.log('‚úì Local session cleared');
          
          // Clear Auth0 session by redirecting to logout endpoint
          // This ensures the user will be prompted to login again
          // Dynamically use the correct Auth0 domain (sandbox or production)
          const auth0Domain = getAuth0Domain();
          const auth0LogoutUrl = `${auth0Domain}/v2/logout?client_id=${OAUTH_CONFIG.clientId}&returnTo=${encodeURIComponent(OAUTH_CONFIG.redirectUri)}`;
          
          console.log('‚úì Redirecting to Auth0 logout:', auth0Domain);
          
          // Redirect to Auth0 logout, which will then redirect back to our app
          window.location.href = auth0LogoutUrl;
        }

        async resetConfiguration() {
          try {
            // Clear OAuth session (but don't redirect to Auth0 logout - we'll reload instead)
            console.log('üîÑ Resetting SideDrawer configuration...');
            
            // Show loading state
            const appContent = document.getElementById('app-content');
            if (appContent) {
              appContent.innerHTML = `
                <div class="loading">
                  <div class="spinner"></div>
                  <p>Resetting configuration...</p>
                </div>
              `;
            }
            
            // Clear periodic refresh interval
            if (this.refreshInterval) {
              clearInterval(this.refreshInterval);
              this.refreshInterval = null;
            }
            
            // Clear Zoho session
            await this.clearZohoSession();
            
            // Clear setup config from custom module (if admin)
            if (window.SetupAPI && typeof window.SetupAPI.deleteSetupConfig === 'function') {
              try {
                await window.SetupAPI.deleteSetupConfig();
                console.log('‚úì Configuration reset: Custom module cleared');
              } catch (error) {
                if (error.message.includes('Permission denied')) {
                  console.warn('‚ö†Ô∏è Cannot delete custom module (permission denied) - delete manually in Zoho');
                } else {
                  console.warn('‚ö†Ô∏è Error deleting custom module:', error);
                }
              }
            }
            
            // Clear localStorage
            localStorage.removeItem('sd_widget_setup_config');
            localStorage.removeItem('sdSession');
            localStorage.removeItem('sidedrawer_refresh_token');
            localStorage.removeItem('sidedrawer_code_verifier');
            
            // Clear all localStorage items related to SideDrawer and Auth0
            Object.keys(localStorage).forEach(key => {
              if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
                localStorage.removeItem(key);
              }
            });
            
            // Clear sessionStorage
            Object.keys(sessionStorage).forEach(key => {
              if (key.startsWith('sd_config_')) {
                sessionStorage.removeItem(key);
              }
            });
            
            // Clear code verifier from sessionStorage
            sessionStorage.removeItem('sidedrawer_code_verifier');
            
            // Reset OAUTH_CONFIG
            OAUTH_CONFIG.clientId = null;
            
            // Clear all Auth0 cookies
            this.clearAllCookies();
            
            console.log('‚úÖ Configuration reset complete');
            
            // Reload to show fresh state
            window.location.reload();
          } catch (error) {
            console.error('Error resetting configuration:', error);
            this.showError('Failed to reset configuration: ' + error.message);
            // Still reload to show disconnected state
            setTimeout(() => window.location.reload(), 2000);
          }
        }
        
        clearAllCookies() {
          // Get all cookies
          const cookies = document.cookie.split(';');
          
          // Clear each cookie by setting expiry to past date
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i];
            const eqPos = cookie.indexOf('=');
            const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
            
            // Clear for current path and domain
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=' + window.location.hostname;
            
            // Try to clear for parent domain (e.g., .sidedrawer.com)
            const domainParts = window.location.hostname.split('.');
            if (domainParts.length > 1) {
              const parentDomain = '.' + domainParts.slice(-2).join('.');
              document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=' + parentDomain;
            }
            
            console.log('üóëÔ∏è Cleared cookie:', name);
          }
        }

        async saveTokens(tokenData) {
          // Store access token in Zoho session (shared across widgets)
          const expiresAt = Date.now() + (tokenData.expires_in * 1000);
          
          // DEBUG: Log what we received from OAuth
          console.log('üíæ Saving tokens - OAuth response contains:');
          console.log('  - access_token:', !!tokenData.access_token, tokenData.access_token ? `(${tokenData.access_token.length} chars)` : 'MISSING');
          console.log('  - refresh_token:', !!tokenData.refresh_token, tokenData.refresh_token ? `(${tokenData.refresh_token.length} chars)` : 'MISSING');
          console.log('  - expires_in:', tokenData.expires_in);
          console.log('  - token_type:', tokenData.token_type);
          console.log('  - All keys in tokenData:', Object.keys(tokenData));
          
          // Get existing refresh token (in case new one not provided)
          // Check both session object and localStorage
          const session = await this.getZohoSession();
          const existingRefreshToken = session?.refreshToken || localStorage.getItem(STORAGE_KEYS.refreshToken);
          
          console.log('üíæ Existing refresh token check:');
          console.log('  - In session object:', !!session?.refreshToken);
          console.log('  - In localStorage:', !!localStorage.getItem(STORAGE_KEYS.refreshToken));
          
          // Use new refresh token if provided, otherwise keep existing one
          const refreshTokenToUse = tokenData.refresh_token || existingRefreshToken;
          
          const sessionData = {
            accessToken: tokenData.access_token,
            expiresAt: expiresAt,
            tokenType: tokenData.token_type || 'Bearer',
            // Store refresh token in session object too (for consistency with @SidedrawerRelated)
            refreshToken: refreshTokenToUse || null
          };
          
          console.log('üíæ Saving session data...');
          console.log('  Access token length:', tokenData.access_token?.length || 0);
          console.log('  Expires at:', new Date(expiresAt).toISOString());
          console.log('  Refresh token in session:', !!sessionData.refreshToken);
          if (sessionData.refreshToken) {
            console.log('  Refresh token preview:', sessionData.refreshToken.substring(0, 20) + '...');
          }
          
          await this.setZohoSession(sessionData);
          
          // Store refresh token in localStorage (persistent) - ALWAYS save if we have one
          if (refreshTokenToUse) {
            localStorage.setItem(STORAGE_KEYS.refreshToken, refreshTokenToUse);
            console.log('‚úÖ Refresh token stored in localStorage:', STORAGE_KEYS.refreshToken);
            console.log('‚úÖ Refresh token also stored in session object');
          } else {
            console.error('‚ùå CRITICAL: No refresh token available to store!');
            console.error('  - OAuth response had refresh_token:', !!tokenData.refresh_token);
            console.error('  - Existing refresh token found:', !!existingRefreshToken);
            console.error('  - This means session cannot be refreshed automatically!');
            console.error('  - User will need to re-authenticate when token expires.');
          }
        }

        async getAccessToken() {
          const session = await this.getZohoSession();
          return session ? session.accessToken : null;
        }

        async getRefreshToken() {
          // PRIORITY 1: Check session object (new format - refresh token stored in session)
          const session = await this.getZohoSession();
          console.log('[getRefreshToken] Checking session object:', {
            hasSession: !!session,
            hasRefreshToken: !!(session?.refreshToken),
            sessionKeys: session ? Object.keys(session) : []
          });
          
          if (session && session.refreshToken) {
            console.log('‚úÖ Refresh token found in session object');
            return session.refreshToken;
          }
          
          // PRIORITY 2: Check legacy localStorage location (for backward compatibility)
          const legacyToken = localStorage.getItem(STORAGE_KEYS.refreshToken);
          console.log('[getRefreshToken] Checking legacy localStorage:', {
            key: STORAGE_KEYS.refreshToken,
            found: !!legacyToken
          });
          
          if (legacyToken) {
            console.log('‚úÖ Refresh token found in legacy localStorage');
            return legacyToken;
          }
          
          // PRIORITY 3: Check all localStorage keys containing "refresh" or "token"
          console.log('[getRefreshToken] Scanning localStorage for refresh tokens...');
          const allKeys = Object.keys(localStorage);
          const tokenKeys = allKeys.filter(k => k.toLowerCase().includes('refresh') || k.toLowerCase().includes('token'));
          console.log('[getRefreshToken] Found potential token keys:', tokenKeys);
          tokenKeys.forEach(key => {
            const value = localStorage.getItem(key);
            console.log(`  - ${key}: ${value ? value.substring(0, 20) + '...' : 'empty'}`);
          });
          
          console.log('‚ö†Ô∏è No refresh token found in session object or localStorage');
          return null;
        }

        isTokenExpired(expiresAt) {
          if (!expiresAt) return true;
          // Add 5 minute buffer before expiry
          const bufferTime = 5 * 60 * 1000;
          return Date.now() >= (parseInt(expiresAt) - bufferTime);
        }

        cleanupOAuthState() {
          localStorage.removeItem(STORAGE_KEYS.codeVerifier);
        }

        // PKCE Helper Functions
        generateCodeVerifier() {
          const array = new Uint8Array(32);
          crypto.getRandomValues(array);
          return this.base64UrlEncode(array);
        }

        async generateCodeChallenge(codeVerifier) {
          const encoder = new TextEncoder();
          const data = encoder.encode(codeVerifier);
          const hash = await crypto.subtle.digest('SHA-256', data);
          return this.base64UrlEncode(new Uint8Array(hash));
        }

        base64UrlEncode(array) {
          return btoa(String.fromCharCode.apply(null, array))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
        }

        generateRandomString(length) {
          const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          let result = '';
          for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          return result;
        }
      }

      // Wait for external resources to load before initializing widget
      // This ensures all dependencies (setup-api.js, tenant-wizard.js, etc.) are available
      (async function initializeWidget() {
        try {
          // Wait for resources to load (or timeout after 5 seconds)
          await Promise.race([
            window.resourcesLoadedPromise || Promise.resolve(true),
            new Promise(resolve => setTimeout(() => {
              console.warn('‚ö†Ô∏è Resource loading timeout - proceeding with initialization');
              resolve(true);
            }, 5000))
          ]);
          
          // Tenant Creation Wizard, StripeService, and TenantCreationWizard classes are in tenant-wizard.js
          const auth = new SideDrawerAuth();
          window.auth = auth; // Make globally accessible
          
          // Note: init() is called from initZoho() after SDK initialization completes
          // Do NOT call auth.init() here - it would run before SDK is ready
        } catch (error) {
          console.error('‚ùå Error during widget initialization:', error);
          // Try to initialize anyway - some features might still work
          try {
            const auth = new SideDrawerAuth();
            window.auth = auth;
            // Note: init() is called from initZoho() after SDK initialization completes
          } catch (fallbackError) {
            console.error('‚ùå Fallback initialization also failed:', fallbackError);
          }
        }
      })();
      
      // Helper function to reset configuration from console
      window.resetSideDrawerConfig = async function() {
        if (!window.auth) {
          console.error('‚ùå Auth instance not available. Please refresh the page.');
          return;
        }
        if (confirm('Are you sure you want to reset all SideDrawer configuration? This will clear credentials and sessions.')) {
          await window.auth.resetConfiguration();
        }
      };
      
      // Fallback reset function (works even if auth not initialized)
      window.resetSideDrawerConfigSimple = function() {
        if (confirm('Reset all SideDrawer configuration? This will clear all stored data.')) {
          // Clear localStorage
          localStorage.removeItem('sd_widget_setup_config');
          localStorage.removeItem('sdSession');
          localStorage.removeItem('sidedrawer_refresh_token');
          localStorage.removeItem('sidedrawer_code_verifier');
          
          // Clear all localStorage items related to SideDrawer and Auth0
          Object.keys(localStorage).forEach(key => {
            if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
              localStorage.removeItem(key);
            }
          });
          
          // Clear sessionStorage
          Object.keys(sessionStorage).forEach(key => {
            if (key.startsWith('sd_config_')) {
              sessionStorage.removeItem(key);
            }
          });
          
          // Clear code verifier from sessionStorage
          sessionStorage.removeItem('sidedrawer_code_verifier');
          
          console.log('‚úÖ Local storage cleared. Refreshing page...');
          window.location.reload();
        }
      };
      
      // Re-assign reset functions after auth creation (fallback - already defined earlier)
      window.resetSideDrawerConfig = async function() {
        if (!window.auth) {
          console.error('‚ùå Auth instance not available. Using simple reset...');
          window.resetSideDrawerConfigSimple();
          return;
        }
        if (confirm('Are you sure you want to reset all SideDrawer configuration? This will clear credentials and sessions.')) {
          await window.auth.resetConfiguration();
        }
      };

      window.resetSideDrawerConfigSimple = window.resetSideDrawerConfigSimple || function() {
        if (confirm('Reset all SideDrawer configuration? This will clear all stored data.')) {
          // Clear localStorage
          localStorage.removeItem('sd_widget_setup_config');
          localStorage.removeItem('sdSession');
          localStorage.removeItem('sidedrawer_refresh_token');
          localStorage.removeItem('sidedrawer_code_verifier');
          
          // Clear all localStorage items related to SideDrawer and Auth0
          Object.keys(localStorage).forEach(key => {
            if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
              localStorage.removeItem(key);
            }
          });
          
          // Clear sessionStorage
          Object.keys(sessionStorage).forEach(key => {
            if (key.startsWith('sd_config_')) {
              sessionStorage.removeItem(key);
            }
          });
          
          sessionStorage.removeItem('sidedrawer_code_verifier');
          
          console.log('‚úÖ Local storage cleared. Refreshing page...');
          window.location.reload();
        }
      };

      console.log('üí° Run resetSideDrawerConfig() in console to reset all configuration');
      console.log('üí° Run resetSideDrawerConfigSimple() for quick reset without auth instance');
      console.log('‚úÖ Reset functions verified:', {
        resetSideDrawerConfig: typeof window.resetSideDrawerConfig,
        resetSideDrawerConfigSimple: typeof window.resetSideDrawerConfigSimple
      });
      
      // Helper function to check session status (can be called from console)
      window.checkSideDrawerSession = async function() {
        console.log('üîç Checking SideDrawer Session Status...');
        console.log('='.repeat(60));
        
        // Check localStorage for session
        const sessionStr = localStorage.getItem('sdSession');
        console.log('üì¶ localStorage key "sdSession":', sessionStr ? 'FOUND' : 'NOT FOUND');
        
        if (sessionStr) {
          try {
            const session = JSON.parse(sessionStr);
            console.log('‚úÖ Session object parsed successfully');
            console.log('  Keys in session:', Object.keys(session));
            console.log('  Has accessToken:', !!session.accessToken);
            console.log('  Has refreshToken:', !!session.refreshToken);
            console.log('  Expires at:', session.expiresAt ? new Date(parseInt(session.expiresAt)).toISOString() : 'N/A');
            
            if (session.expiresAt) {
              const now = Date.now();
              const expiresAt = parseInt(session.expiresAt);
              const timeUntilExpiry = Math.floor((expiresAt - now) / 1000);
              console.log('  Time until expiry:', timeUntilExpiry, 'seconds');
              console.log('  Is expired:', timeUntilExpiry < 0 ? 'YES ‚ùå' : 'NO ‚úÖ');
            }
            
            if (session.refreshToken) {
              console.log('  Refresh token preview:', session.refreshToken.substring(0, 20) + '...');
            } else {
              console.log('  ‚ö†Ô∏è NO REFRESH TOKEN IN SESSION OBJECT!');
            }
          } catch (e) {
            console.error('‚ùå Failed to parse session:', e);
          }
        }
        
        // Check localStorage for separate refresh token
        const refreshTokenKey = 'sidedrawer_refresh_token';
        const refreshToken = localStorage.getItem(refreshTokenKey);
        console.log('üì¶ localStorage key "' + refreshTokenKey + '":', refreshToken ? 'FOUND ‚úÖ' : 'NOT FOUND ‚ùå');
        if (refreshToken) {
          console.log('  Refresh token preview:', refreshToken.substring(0, 20) + '...');
        }
        
        // Check sessionStorage
        const sessionStorageStr = sessionStorage.getItem('sdSession');
        console.log('üì¶ sessionStorage key "sdSession":', sessionStorageStr ? 'FOUND' : 'NOT FOUND');
        
        console.log('='.repeat(60));
        
        if (!sessionStr || !refreshToken) {
          console.log('‚ö†Ô∏è NO REFRESH TOKEN FOUND!');
          console.log('');
          console.log('üìã This means:');
          console.log('  1. Your session was created BEFORE refresh token storage was added');
          console.log('  2. OR the OAuth response did not include refresh_token');
          console.log('  3. Session cannot be automatically refreshed');
          console.log('');
          console.log('‚úÖ SOLUTION: Re-authenticate to get a fresh session with refresh token');
          console.log('  - Click "Connect to SideDrawer" button in the widget');
          console.log('  - OR run: auth.startOAuthFlow()');
          console.log('');
          console.log('‚úÖ After re-authentication, refresh token will be stored in:');
          console.log('  - Session object: sdSession.refreshToken');
          console.log('  - localStorage: sidedrawer_refresh_token');
        } else {
          console.log('‚úÖ Refresh token found! Session can be automatically refreshed.');
          console.log('üí° Run: auth.checkConnection() to test refresh');
        }
      };
      
      console.log('üí° Run checkSideDrawerSession() in console to check session status');
      
      // Helper function to check and fix permission status
      window.checkSideDrawerPermissions = async function() {
        console.log('üîç Checking SideDrawer Permission Status...');
        console.log('='.repeat(60));
        console.log('Stored hasManageOrgPermission:', auth.hasManageOrgPermission);
        console.log('isStandalone:', window.self === window.top);
        
        if (window.SetupAPI && typeof window.SetupAPI.checkUserHasManageOrgPermission === 'function') {
          try {
            const hasPermission = await window.SetupAPI.checkUserHasManageOrgPermission();
            console.log('Current permission check result:', hasPermission);
            console.log('Permission matches stored value:', hasPermission === auth.hasManageOrgPermission);
            
            if (hasPermission && !auth.hasManageOrgPermission) {
              console.warn('‚ö†Ô∏è MISMATCH: User has permissions but widget thinks they don\'t!');
              console.warn('‚ö†Ô∏è Updating hasManageOrgPermission to true...');
              auth.hasManageOrgPermission = true;
              console.log('‚úì Updated. Re-rendering UI...');
              auth.showDisconnectedStatus(); // Re-render with buttons
            }
          } catch (error) {
            console.error('Error checking permissions:', error);
          }
        } else {
          console.warn('SetupAPI.checkUserHasManageOrgPermission not available');
        }
        
        console.log('='.repeat(60));
      };
      
      console.log('üí° Run checkSideDrawerPermissions() in console to check and fix permission status');
      
      // Ensure reset functions are available on DOM ready (final fallback)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          if (typeof window.resetSideDrawerConfig === 'undefined') {
            console.warn('‚ö†Ô∏è Reset functions not found, redefining...');
            window.resetSideDrawerConfigSimple();
          }
        });
      } else {
        // DOM already loaded, verify functions exist
        if (typeof window.resetSideDrawerConfig === 'undefined') {
          console.warn('‚ö†Ô∏è Reset functions not found after page load');
        }
      }
    </script>
  </body>
</html>
