<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SideDrawer Integration</title>
    <!-- Zoho CRM SDK -->
    <script src="https://live.zwidgets.com/js-sdk/1.2/ZohoEmbededAppSDK.min.js"></script>
    <!-- Stripe.js for PCI-compliant payment processing -->
    <script src="https://js.stripe.com/v3/"></script>
    <!-- External CSS -->
    <link rel="stylesheet" href="widget.css">
    <!-- Tenant Creation Wizard (non-logged-in) -->
    <script src="tenant-wizard.js"></script>
    <!-- Tenant Creation Wizard (logged-in) -->
    <script src="tenant-wizard-with-credentials.js"></script>
    <!-- Setup API for credential management -->
    <script src="setup-api.js"></script>
    <!-- Setup Modal Component -->
    <script src="setup-modal.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>SideDrawer Integration</h1>
        <p>Connect your Zoho CRM with SideDrawer</p>
      </div>

      <div id="app-content">
        <div class="loading">
          <div class="spinner"></div>
          <p>Initializing connection...</p>
        </div>
      </div>
      
      <!-- Tenant Creation Wizard Container (hidden by default) -->
      <div id="tenant-wizard" class="hidden"></div>
    </div>

      <script>
      // Read URL parameters for initial config
      const urlParams = new URLSearchParams(window.location.search);
      const isOAuthCallback = urlParams.has('code') || urlParams.has('error');
      
      // Helper to get config param (from URL or sessionStorage)
      function getConfigParam(key) {
        // If URL has param, use and store it
        if (urlParams.has(key)) {
          const value = urlParams.get(key);
          if (!isOAuthCallback) {
            sessionStorage.setItem('sd_config_' + key, value);
          }
          return value;
        }
        // Otherwise try sessionStorage
        return sessionStorage.getItem('sd_config_' + key) || null;
      }
      
      // OAuth2 Configuration (will be updated with Zoho config if available)
      const OAUTH_CONFIG = {
        authorizationEndpoint: 'https://auth-sbx.sidedrawersbx.com/authorize',
        tokenEndpoint: 'https://auth-sbx.sidedrawersbx.com/oauth/token',
        clientId: getConfigParam('client_id') || null,
        audience: 'https://user-api-sbx.sidedrawersbx.com',
        redirectUri: getConfigParam('redirect_uri') || (window.location.origin + window.location.pathname.split('?')[0]),
        scope: 'openid profile email offline_access'
      };
      
      // Log initial configuration
      console.log('üîß Initial OAuth Config (PKCE - NO CLIENT SECRET):');
      console.log('  Client ID:', OAUTH_CONFIG.clientId ? 'Set' : 'NOT SET');
      console.log('  Redirect URI:', OAUTH_CONFIG.redirectUri);
      console.log('  Is OAuth Callback:', isOAuthCallback);

      // Storage keys
      const STORAGE_KEYS = {
        refreshToken: 'sidedrawer_refresh_token', // Persistent in localStorage
        codeVerifier: 'sidedrawer_code_verifier'
      };

      const ZOHO_SESSION_KEY = 'sdSession'; // Zoho session storage key
      
      // Helper function to extract Auth0 domain from authorization endpoint
      function getAuth0Domain() {
        try {
          const url = new URL(OAUTH_CONFIG.authorizationEndpoint);
          return url.origin; // Returns https://auth-sbx.sidedrawersbx.com or https://auth.sidedrawer.com
        } catch (e) {
          console.error('Failed to parse Auth0 domain:', e);
          return 'https://auth-sbx.sidedrawersbx.com'; // Fallback to sandbox
        }
      }

      class SideDrawerAuth {
        constructor() {
          this.zohoInitialized = false;
          this.refreshInterval = null;
          this.hasManageOrgPermission = false; // Store permission status
          this.setupModal = null; // Setup modal instance
          this.initZoho();
        }

        async initZoho() {
          // Helper function to extract client_id from sd_config_redirect_uri sessionStorage
          const extractClientIdFromRedirectUri = () => {
            const redirectUri = sessionStorage.getItem('sd_config_redirect_uri');
            if (redirectUri) {
              try {
                const url = new URL(redirectUri);
                const clientId = url.searchParams.get('client_id');
                if (clientId) {
                  console.log('[SideDrawer Widget] ‚úì Extracted client_id from redirect_uri:', clientId);
                  return clientId;
                }
              } catch (e) {
                console.warn('[SideDrawer Widget] Failed to parse redirect_uri:', e);
              }
            }
            return null;
          };
          
          // Helper function to get client_id from multiple sources
          const getClientId = () => {
            // Priority 1: URL params
            const urlClientId = urlParams.get('client_id');
            if (urlClientId) {
              return urlClientId;
            }
            
            // Priority 2: Extract from sd_config_redirect_uri
            const redirectUriClientId = extractClientIdFromRedirectUri();
            if (redirectUriClientId) {
              return redirectUriClientId;
            }
            
            // Priority 3: From OAUTH_CONFIG (which may have been set from sessionStorage)
            if (OAUTH_CONFIG.clientId) {
              return OAUTH_CONFIG.clientId;
            }
            
            return null;
          };
          
          // When loaded in Zoho, respond to postMessage requests for session data
          window.addEventListener('message', async (event) => {
            // Handle REFRESH_SIDEDRAWER_TOKEN message
            if (event.data && event.data.type === 'REFRESH_SIDEDRAWER_TOKEN') {
              console.log('[SideDrawer Widget] üîÑ Received token refresh request');
              
              try {
                // Get client_id from multiple sources
                const clientId = getClientId();
                
                if (!clientId) {
                  throw new Error('client_id not found in URL params, redirect_uri, or sessionStorage');
                }
                
                // Update OAUTH_CONFIG.clientId if needed
                if (!OAUTH_CONFIG.clientId) {
                  OAUTH_CONFIG.clientId = clientId;
                  console.log('[SideDrawer Widget] ‚úì Set OAUTH_CONFIG.clientId from getClientId():', clientId);
                }
                
                console.log('[SideDrawer Widget] Client ID for refresh:', clientId);
                
                // Call the existing refreshAccessToken method
                await this.refreshAccessToken();
                
                // Get the refreshed session
                const refreshedSession = await this.getZohoSession();
                
                if (refreshedSession && refreshedSession.accessToken) {
                  // Ensure clientId is in session
                  if (!refreshedSession.clientId) {
                    refreshedSession.clientId = clientId;
                  }
                  
                  console.log('[SideDrawer Widget] ‚úÖ Token refreshed successfully');
                  console.log('[SideDrawer Widget] New token expires at:', refreshedSession.expiresAt ? new Date(parseInt(refreshedSession.expiresAt)).toISOString() : 'N/A');
                  
                  // Send refreshed session back to parent
                  window.parent.postMessage({
                    type: 'SIDEDRAWER_SESSION_RESPONSE',
                    session: refreshedSession
                  }, '*');
                } else {
                  throw new Error('Failed to get refreshed session after token refresh');
                }
                
              } catch (error) {
                console.error('[SideDrawer Widget] ‚ùå Token refresh error:', error);
                window.parent.postMessage({
                  type: 'SIDEDRAWER_SESSION_RESPONSE',
                  session: null,
                  error: error.message
                }, '*');
              }
              
              return; // Exit early, don't process REQUEST_SIDEDRAWER_SESSION
            }
            
            // Handle REQUEST_SIDEDRAWER_SESSION message
            if (event.data && event.data.type === 'REQUEST_SIDEDRAWER_SESSION') {
              console.log('üì• Received session request from parent window');
              const session = localStorage.getItem('sdSession');
              if (session) {
                try {
                  const sessionData = JSON.parse(session);
                  
                  // Ensure clientId is in session (extract from multiple sources if missing)
                  if (!sessionData.clientId) {
                    const clientId = getClientId();
                    if (clientId) {
                      sessionData.clientId = clientId;
                      // Update stored session with clientId
                      localStorage.setItem('sdSession', JSON.stringify(sessionData));
                    }
                  }
                  
                  window.parent.postMessage({
                    type: 'SIDEDRAWER_SESSION_RESPONSE',
                    session: sessionData
                  }, '*');
                  console.log('üì§ Sent session to parent window');
                } catch (e) {
                  console.error('Failed to parse/send session:', e);
                }
              } else {
                console.log('‚ö† No session available to send');
                // Send null session response
                window.parent.postMessage({
                  type: 'SIDEDRAWER_SESSION_RESPONSE',
                  session: null
                }, '*');
              }
            }
          });
          
          console.log('‚úÖ Session bridge ready (localStorage only, no Zoho SDK needed)');
          
          try {
            // Set up message listener for OAuth popup callback
            window.addEventListener('message', async (event) => {
              console.log('üì® Parent received message:', event.data?.type || 'unknown');
              
              // Verify origin for security
              if (event.origin !== window.location.origin) {
                console.warn('‚ö† Ignoring message from different origin:', event.origin);
                return;
              }
              
              if (event.data && event.data.type === 'SIDEDRAWER_OAUTH_TOKENS') {
                console.log('‚úÖ Received OAuth tokens from popup');
                console.log('Has access_token:', !!event.data.tokens?.access_token);
                console.log('Has refresh_token:', !!event.data.tokens?.refresh_token);
                
                // Show processing message
                document.getElementById('app-content').innerHTML = `
                  <div class="loading">
                    <div class="spinner"></div>
                    <p>Saving authentication...</p>
                  </div>
                `;
                
                try {
                  // Save the tokens
                  await this.saveTokens(event.data.tokens);
                  console.log('‚úÖ Tokens saved successfully');
                  
                  // Show connected status
                  await this.checkConnection();
                } catch (error) {
                  console.error('‚ùå Failed to save tokens:', error);
                  this.showError(`Failed to save authentication: ${error.message}`);
                }
              } else if (event.data && event.data.type === 'SIDEDRAWER_OAUTH_ERROR') {
                console.error('‚ùå OAuth error from popup:', event.data.error);
                this.showError(`Authentication failed: ${event.data.error}`);
              }
            });

            // Initialize setup modal
            if (typeof window.SetupModal !== 'undefined') {
              this.setupModal = new window.SetupModal(this);
              window.setupModal = this.setupModal; // Make globally accessible
            }
            
            // Initialize after Zoho setup (or fallback)
            console.log('Proceeding with initialization (Zoho initialized:', this.zohoInitialized, ')');
            console.log('OAuth Redirect URI:', OAUTH_CONFIG.redirectUri);
            this.init();
          } catch (error) {
            console.error('Initialization error:', error);
          }
        }

        async loadZohoConfig() {
          try {
            // Check user permissions first
            if (window.SetupAPI && typeof window.SetupAPI.checkUserHasManageOrgPermission === 'function') {
              this.hasManageOrgPermission = await window.SetupAPI.checkUserHasManageOrgPermission();
              console.log('‚úì Permission check:', this.hasManageOrgPermission ? 'Admin (can configure)' : 'Standard User (read-only)');
            }
            
            // Priority 1: Try custom module first (via SetupAPI)
            if (window.SetupAPI && typeof window.SetupAPI.getCredentials === 'function') {
              const credentials = await window.SetupAPI.getCredentials();
              
              if (credentials && credentials.clientId) {
                console.log('‚úì Loaded credentials from:', credentials.source);
                
                // Set OAuth config from custom module
                OAUTH_CONFIG.clientId = credentials.clientId;
                
                if (credentials.redirectUri) {
                  OAUTH_CONFIG.redirectUri = credentials.redirectUri;
                  console.log('‚úì Using redirect URI from custom module:', OAUTH_CONFIG.redirectUri);
                }
                
                // Set environment endpoints
                if (credentials.environment === 'production') {
                  OAUTH_CONFIG.authorizationEndpoint = 'https://auth.sidedrawer.com/authorize';
                  OAUTH_CONFIG.tokenEndpoint = 'https://auth.sidedrawer.com/oauth/token';
                  OAUTH_CONFIG.audience = 'https://user-api.sidedrawer.com';
                  console.log('‚úì Using PRODUCTION environment');
                } else {
                  // Sandbox (default)
                  OAUTH_CONFIG.authorizationEndpoint = 'https://auth-sbx.sidedrawersbx.com/authorize';
                  OAUTH_CONFIG.tokenEndpoint = 'https://auth-sbx.sidedrawersbx.com/oauth/token';
                  OAUTH_CONFIG.audience = 'https://user-api-sbx.sidedrawersbx.com';
                  console.log('‚úì Using SANDBOX environment');
                }
                
                return; // Successfully loaded from custom module
              }
            }
            
            // Priority 2: Fallback to widget variables
            const config = await ZOHO.CRM.CONFIG.getVariables();
            
            if (config) {
              console.log('‚úì Loaded Zoho widget variables (fallback):', Object.keys(config));
              
              // Redirect URI (REQUIRED in production)
              if (config.redirect_uri && config.redirect_uri.trim()) {
                OAUTH_CONFIG.redirectUri = config.redirect_uri.trim();
                console.log('‚úì Using configured redirect URI:', OAUTH_CONFIG.redirectUri);
              } else {
                console.warn('‚ö† No redirect URI configured - using auto-detection (may not work behind proxies)');
                console.log('Current URL:', OAUTH_CONFIG.redirectUri);
              }
              
              // Client ID (can also come from URL params)
              if (config.client_id && config.client_id.trim()) {
                OAUTH_CONFIG.clientId = config.client_id.trim();
                console.log('‚úì Client ID loaded from Zoho config');
              }
              
              // Environment (REQUIRED)
              if (config.environment === 'production') {
                OAUTH_CONFIG.authorizationEndpoint = 'https://auth.sidedrawer.com/authorize';
                OAUTH_CONFIG.tokenEndpoint = 'https://auth.sidedrawer.com/oauth/token';
                OAUTH_CONFIG.audience = 'https://user-api.sidedrawer.com';
                console.log('‚úì Using PRODUCTION environment');
              } else if (config.environment === 'sandbox') {
                // Already set to sandbox by default
                console.log('‚úì Using SANDBOX environment');
              } else {
                console.warn('‚ö† No environment configured - using sandbox (default)');
              }
            } else {
              console.warn('‚ö† No Zoho configuration found - using defaults (development mode)');
            }
          } catch (error) {
            console.warn('‚ö† Could not load Zoho config, using defaults (development mode):', error.message);
          }
        }

        // Simple localStorage-only session management
        async setZohoSession(data) {
          localStorage.setItem(ZOHO_SESSION_KEY, JSON.stringify(data));
          console.log('‚úì Stored session in localStorage');
          return true;
        }

        async getZohoSession() {
          const data = localStorage.getItem(ZOHO_SESSION_KEY);
          return data ? JSON.parse(data) : null;
        }

        async clearZohoSession() {
          localStorage.removeItem(ZOHO_SESSION_KEY);
          console.log('‚úì Cleared session from localStorage');
        }

        async init() {
          // Check if we're returning from OAuth redirect
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get('code');
          const error = urlParams.get('error');

          // Check if we're in a popup window opened for OAuth
          const isPopup = window.opener && !window.opener.closed;

          if (error) {
            if (isPopup) {
              // Close popup and let parent handle error
              window.close();
            } else {
              this.showError(`Authentication error: ${error}`);
              this.cleanupOAuthState();
            }
            return;
          }

          if (code) {
            if (isPopup) {
              // We're in the OAuth popup - exchange code for tokens and pass to parent
              console.log('üîê OAuth popup: Received authorization code');
              console.log('Code:', code.substring(0, 20) + '...');
              
              // Show loading in popup
              document.getElementById('app-content').innerHTML = `
                <div class="loading">
                  <div class="spinner"></div>
                  <p>Completing authentication...</p>
                  <p class="text-small-gray mt-10">This window will close automatically...</p>
                </div>
              `;
              
              try {
                // IMPORTANT: Try state parameter FIRST (most reliable, can't be stale)
                let codeVerifier = null;
                const state = urlParams.get('state');
                console.log('üîç State parameter from URL:', state ? state.substring(0, 50) + '...' : 'NOT FOUND');
                
                if (state) {
                  try {
                    const decoded = atob(state);
                    console.log('üîç Decoded state:', decoded);
                    const stateData = JSON.parse(decoded);
                    console.log('üîç Parsed state data:', stateData);
                    codeVerifier = stateData.verifier;
                    console.log('‚úÖ Code verifier from state parameter:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                  } catch (e) {
                    console.warn('‚ö† Could not parse state parameter:', e);
                    console.error('State parsing error details:', e.stack);
                  }
                }
                
                // Fallback to localStorage only if state failed
                if (!codeVerifier) {
                  codeVerifier = localStorage.getItem(STORAGE_KEYS.codeVerifier);
                  console.log('Code verifier from localStorage:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                }
                
                // Last resort: sessionStorage
                if (!codeVerifier) {
                  codeVerifier = sessionStorage.getItem(STORAGE_KEYS.codeVerifier);
                  console.log('Code verifier from sessionStorage:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                }
                
                if (!codeVerifier) {
                  throw new Error('Code verifier not found in localStorage, sessionStorage, or state parameter');
                }
                
                console.log('‚úì Code verifier found, exchanging code for tokens...');
                console.log('Code verifier length:', codeVerifier.length);
                console.log('Code verifier sample:', codeVerifier.substring(0, 20) + '...' + codeVerifier.substring(codeVerifier.length - 10));
                console.log('Token endpoint:', OAUTH_CONFIG.tokenEndpoint);
                console.log('Client ID:', OAUTH_CONFIG.clientId);
                console.log('Redirect URI:', OAUTH_CONFIG.redirectUri);

                const tokenRequestBody = {
                  grant_type: 'authorization_code',
                  client_id: OAUTH_CONFIG.clientId,
                  code: code,
                  code_verifier: codeVerifier,
                  redirect_uri: OAUTH_CONFIG.redirectUri,
                  audience: OAUTH_CONFIG.audience
                };

                const tokenResponse = await fetch(OAUTH_CONFIG.tokenEndpoint, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(tokenRequestBody)
                });

                console.log('Token response status:', tokenResponse.status, tokenResponse.statusText);

                if (!tokenResponse.ok) {
                  const responseText = await tokenResponse.text();
                  console.error('‚ùå Token exchange error response (raw):', responseText);
                  let errorData;
                  try {
                    errorData = JSON.parse(responseText);
                  } catch (e) {
                    errorData = { error: 'Parse error', raw: responseText };
                  }
                  console.error('‚ùå Token exchange error (parsed):', errorData);
                  throw new Error(errorData.error_description || errorData.error || `Token exchange failed: ${tokenResponse.status}`);
                }

                const tokenData = await tokenResponse.json();
                console.log('‚úÖ Token exchange successful!');
                console.log('Has access_token:', !!tokenData.access_token);
                console.log('Has refresh_token:', !!tokenData.refresh_token);
                console.log('Expires in:', tokenData.expires_in);
                
                // Show success message in popup
                document.getElementById('app-content').innerHTML = `
                  <div class="success-message">
                    ‚úì Authentication successful!
                    <br><small>Closing window...</small>
                  </div>
                `;
                
                // Send tokens to parent window
                if (window.opener && !window.opener.closed) {
                  console.log('Sending tokens to parent window...');
                  window.opener.postMessage({ 
                    type: 'SIDEDRAWER_OAUTH_TOKENS',
                    tokens: tokenData
                  }, window.location.origin);
                  console.log('‚úÖ Tokens sent to parent');
                } else {
                  console.warn('‚ö† Parent window not available');
                }
                
                // Clean up and close
                localStorage.removeItem(STORAGE_KEYS.codeVerifier);
                sessionStorage.removeItem(STORAGE_KEYS.codeVerifier);
                setTimeout(() => {
                  console.log('Closing popup...');
                  window.close();
                }, 1000);
                
              } catch (error) {
                console.error('‚ùå OAuth popup error:', error);
                console.error('Error details:', error.stack);
                
                // Show error message in popup
                document.getElementById('app-content').innerHTML = `
                  <div class="error-message">
                    ‚úó Authentication failed
                    <br><small>${error.message}</small>
                    <br><small class="mt-10 block">Check browser console for details. Window will close in 5 seconds...</small>
                  </div>
                `;
                
                // Send error to parent
                if (window.opener && !window.opener.closed) {
                  window.opener.postMessage({ 
                    type: 'SIDEDRAWER_OAUTH_ERROR',
                    error: error.message
                  }, window.location.origin);
                }
                setTimeout(() => window.close(), 5000);
              }
              return;
            } else {
              // Normal flow (not in popup) - handle callback directly
              await this.handleOAuthCallback(code);
              return;
            }
          }

          // Check existing token
          const hasSession = await this.checkConnection();
        }

        async checkConnection() {
          // Try to get existing session
          const session = await this.getZohoSession();
          const refreshToken = await this.getRefreshToken();
          
          // Check if session exists and token is valid
          if (session && session.accessToken && !this.isTokenExpired(session.expiresAt)) {
            // Valid session exists - check if tenant exists
            console.log('‚úì Valid session found');
            const hasTenant = await this.checkTenantExists();
            if (!hasTenant) {
              // No tenant - show connected status with "Create new tenant" button instead of auto-showing wizard
              this.showConnectedStatus(); // Will include the button
              return false;
            }
            this.showConnectedStatus();
            return true;
          } else if (session && session.accessToken && this.isTokenExpired(session.expiresAt)) {
            // Session exists but token is EXPIRED
            // DON'T refresh immediately on page load (F5) - let ensureValidSession() handle it when needed
            // This prevents wasting silver bullets with invalid refresh tokens
            console.log('‚ö†Ô∏è Expired session detected on page load');
            console.log('  Expires at:', session.expiresAt ? new Date(parseInt(session.expiresAt)).toISOString() : 'N/A');
            console.log('  Current time:', new Date().toISOString());
            console.log('  Refresh token available:', refreshToken ? 'YES' : 'NO');
            console.log('  Session keys:', session ? Object.keys(session) : []);
            console.log('  Note: Refresh will happen automatically when needed via ensureValidSession()');
            
            if (refreshToken) {
              // Show connected status - refresh will happen when API calls are made
              this.showConnectedStatus();
              return true;
            } else {
              console.warn('‚ö†Ô∏è Expired session found but no refresh token available');
              console.warn('‚ö†Ô∏è This session was created before refresh token storage was added');
              console.warn('‚ö†Ô∏è You need to re-authenticate to get a refresh token');
              
              // Show helpful error message
              document.getElementById('app-content').innerHTML = `
                <div class="status-card error">
                  <div class="status-indicator">
                    <div class="status-dot error"></div>
                    <span class="status-text">Session Expired - Re-authentication Required</span>
                  </div>
                  <p class="status-info-text">
                    Your session expired and cannot be refreshed automatically because it was created before refresh token storage was implemented.
                  </p>
                  <p class="status-info-text">
                    Please click "Connect to SideDrawer" below to re-authenticate. Your new session will include refresh token support.
                  </p>
                </div>
                <button class="btn btn-success mt-20" onclick="auth.startOAuthFlow()">Connect to SideDrawer</button>
              `;
            }
          } else if (refreshToken) {
            // No session but have refresh token - try silent refresh
            console.log('üîÑ No session found, but refresh token exists - attempting refresh...');
            document.getElementById('app-content').innerHTML = `
              <div class="loading">
                <div class="spinner"></div>
                <p>Refreshing connection...</p>
              </div>
            `;
            await this.refreshAccessToken();
          } else {
            // No valid session or refresh token
            console.log('‚ö†Ô∏è No session or refresh token found');
            
            // Show disconnected status with "Create new tenant" button
            this.showDisconnectedStatus();
            return false;
          }
        }

        startPeriodicTokenRefresh() {
          // REMOVED: Periodic refresh wastes silver bullets
          // Token refresh is now handled reactively by ensureValidSession() when actually needed
          // This prevents unnecessary refresh attempts that waste refresh tokens
        }

        async showConnectedStatus() {
          // Periodic refresh removed - refresh happens reactively when needed via ensureValidSession()
          
          const session = await this.getZohoSession();
          const expiryDate = session ? new Date(parseInt(session.expiresAt)) : new Date();
          const hasRefreshToken = !!(await this.getRefreshToken());
          
          document.getElementById('app-content').innerHTML = `
            <div class="status-card connected">
              <div class="status-indicator">
                <div class="status-dot connected"></div>
                <span class="status-text">Connected to SideDrawer</span>
              </div>
              <p class="status-info-text">Your integration is active and ready to use.</p>
            </div>

            <div class="status-info-box">
              <p class="status-info-item"><strong class="status-info-label">Status:</strong> Authenticated</p>
              <p class="status-info-item"><strong class="status-info-label">Storage:</strong> ${this.zohoInitialized ? 'Zoho Session (shared across widgets)' : 'localStorage (fallback)'}</p>
              <p class="status-info-item"><strong class="status-info-label">Token Expires:</strong> ${expiryDate.toLocaleString()}</p>
              <p class="status-info-item"><strong class="status-info-label">Silent Refresh:</strong> ${hasRefreshToken ? 'Enabled' : 'Disabled'}</p>
            </div>

            <div class="button-group">
              <button class="btn" onclick="auth.disconnect()">Disconnect</button>
              <button class="btn btn-success" onclick="auth.testConnection()">Test Connection</button>
              ${this.hasManageOrgPermission ? `
                <button class="btn btn-primary" onclick="auth.showTenantCreationFlow()">Create New Tenant</button>
                <button class="btn btn-outline" onclick="auth.showSetupModal()">‚öôÔ∏è Setup</button>
              ` : ''}
            </div>

            <div id="test-result"></div>
          `;
        }

        showDisconnectedStatus() {
          document.getElementById('app-content').innerHTML = `
            <div class="status-card">
              <div class="status-indicator">
                <div class="status-dot"></div>
                <span class="status-text">Not Connected</span>
              </div>
              <p class="text-muted-sm">Connect your SideDrawer account to enable the integration.</p>
            </div>

            <div class="info-section">
              <p><strong>What is SideDrawer?</strong></p>
              <p>SideDrawer is a secure document storage and sharing platform designed for financial advisors and their clients.</p>
              <br>
              <p><strong>This integration allows you to:</strong></p>
              <ul class="list-item-spaced">
                <li>Access SideDrawer documents directly from Zoho CRM</li>
                <li>Share content with clients through SideDrawer</li>
                <li>Manage client documents securely</li>
              </ul>
            </div>

            <button class="btn btn-success" onclick="auth.startOAuthFlow()">Connect to SideDrawer</button>
            ${this.hasManageOrgPermission ? `
              <button class="btn btn-outline mt-10" onclick="auth.showTenantCreationFlow()">Create New Tenant</button>
              <button class="btn btn-outline mt-10" onclick="auth.showSetupModal()">‚öôÔ∏è Setup</button>
            ` : ''}
          `;
        }

        showError(message, showDisconnect = false) {
          const disconnectButton = showDisconnect ? `
            <button class="btn" onclick="auth.disconnect()" style="background: #dc3545; margin-left: 10px;">
              Disconnect & Re-authenticate
            </button>
          ` : '';
          
          document.getElementById('app-content').innerHTML = `
            <div class="status-card error">
              <div class="status-indicator">
                <div class="status-dot error"></div>
                <span class="status-text">Connection Error</span>
              </div>
              <div class="error-message">
                ${message}
              </div>
            </div>

            <button class="btn" onclick="auth.checkConnection()">Try Again</button>
            ${disconnectButton}
          `;
        }

        async checkTenantExists() {
          try {
            const token = await this.getAccessToken();
            if (!token) return false;

            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const tenantApi = isSandbox
              ? 'https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/tenant/shared'
              : 'https://tenants-gateway-api.sidedrawer.com/api/v1/tenants/tenant/shared';

            const response = await fetch(tenantApi, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });

            if (response.ok) {
              const tenants = await response.json();
              return tenants && tenants.length > 0;
            }
            return false;
          } catch (error) {
            console.error('‚ùå Error checking tenant:', error);
            return false;
          }
        }

        async showSetupModal(options = {}) {
          if (!this.setupModal) {
            if (typeof window.SetupModal !== 'undefined') {
              this.setupModal = new window.SetupModal(this);
              window.setupModal = this.setupModal;
            } else {
              this.showError('Setup modal is not available. Please refresh the page.');
              return;
            }
          }
          await this.setupModal.open(options);
        }

        async showTenantCreationFlow() {
          // Check permissions first
          if (!this.hasManageOrgPermission) {
            this.showError('Permission denied: Only users with "Manage Organization" rights can create tenants.');
            return;
          }
          const session = await this.getZohoSession();
          const token = await this.getAccessToken();
          
          // Ensure tenant-wizard container exists
          let wizardContainer = document.getElementById('tenant-wizard');
          if (!wizardContainer) {
            wizardContainer = document.createElement('div');
            wizardContainer.id = 'tenant-wizard';
            wizardContainer.style.display = 'none';
            const container = document.querySelector('.container');
            if (container) {
              container.appendChild(wizardContainer);
            } else {
              document.body.appendChild(wizardContainer);
            }
          }
          
          // Hide main content
          const appContent = document.getElementById('app-content');
          if (appContent) {
            appContent.style.display = 'none';
          }
          
          // Determine which wizard to use based on auth state
          if (session && token) {
            // Logged-in user - use credentials wizard
            let attempts = 0;
            const maxAttempts = 50;
            
            while (attempts < maxAttempts) {
              if (typeof window.tenantWizardWithCredentials !== 'undefined' && window.tenantWizardWithCredentials) {
                try {
                  await window.tenantWizardWithCredentials.init(token);
                  return;
                } catch (error) {
                  const dict = window.tenantWizardWithCredentials?.state?.dictionary || {};
                  this.showError(dict.globalparams_error || 'Failed to initialize tenant creation wizard: ' + error.message);
                  return;
                }
              }
              await new Promise(resolve => setTimeout(resolve, 100));
              attempts++;
            }
            
            this.showError('Tenant creation wizard for logged-in users is not available. Please refresh the page.');
          } else {
            // Non-logged-in user - use existing wizard
            let attempts = 0;
            const maxAttempts = 50;
            
            while (attempts < maxAttempts) {
              if (typeof window.tenantWizard !== 'undefined' && window.tenantWizard) {
                try {
                  await window.tenantWizard.init();
                  return;
                } catch (error) {
                  const dict = window.tenantWizard?.state?.dictionary || {};
                  this.showError(dict.globalparams_error || 'Failed to initialize tenant creation wizard: ' + error.message);
                  return;
                }
              }
              await new Promise(resolve => setTimeout(resolve, 100));
              attempts++;
            }
            
            this.showError('Tenant creation wizard is not available. Please refresh the page.');
          }
        }

        async startOAuthFlow() {
          try {
            // Validate configuration
            if (!OAUTH_CONFIG.clientId) {
              // If no OAuth config, show tenant creation flow directly
              await this.showTenantCreationFlow();
              return;
            }
            
            // Generate PKCE code verifier and challenge
            const codeVerifier = this.generateCodeVerifier();
            const codeChallenge = await this.generateCodeChallenge(codeVerifier);

            // Store code verifier in BOTH localStorage and sessionStorage for redundancy
            localStorage.setItem(STORAGE_KEYS.codeVerifier, codeVerifier);
            sessionStorage.setItem(STORAGE_KEYS.codeVerifier, codeVerifier);
            console.log('‚úì Code verifier stored:', codeVerifier.substring(0, 10) + '...');
            console.log('‚úì Code verifier length:', codeVerifier.length);

            // Build authorization URL with state containing code verifier for fallback
            const stateObj = {
              random: this.generateRandomString(16),
              verifier: codeVerifier
            };
            const state = JSON.stringify(stateObj);
            const encodedState = btoa(state);
            
            const authUrl = new URL(OAUTH_CONFIG.authorizationEndpoint);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('client_id', OAUTH_CONFIG.clientId);
            authUrl.searchParams.append('redirect_uri', OAUTH_CONFIG.redirectUri);
            authUrl.searchParams.append('scope', OAUTH_CONFIG.scope);
            authUrl.searchParams.append('audience', OAUTH_CONFIG.audience);
            authUrl.searchParams.append('code_challenge', codeChallenge);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('state', encodedState);

            // Check if we're running inside an iframe (Zoho)
            const isInIframe = window.self !== window.top;

            if (isInIframe) {
              // Open popup window for OAuth (works in Zoho iframe)
              const width = 600;
              const height = 700;
              const left = (screen.width - width) / 2;
              const top = (screen.height - height) / 2;
              
              const popupUrl = authUrl.toString();
              
              const popup = window.open(
                popupUrl,
                'SideDrawer OAuth',
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
              );

              if (!popup) {
                throw new Error('Popup blocked! Please allow popups for this site and try again.');
              }

              // Show waiting status
              document.getElementById('app-content').innerHTML = `
                <div class="status-card">
                  <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span class="status-text">Authenticating...</span>
                  </div>
                  <p class="auth-info-text">Please complete the login in the popup window.</p>
                  <p class="auth-info-text-small">
                    Don't see the popup? Check if your browser blocked it and allow popups for this site.
                  </p>
                </div>
              `;

              // Poll for popup close or callback
              const pollInterval = setInterval(() => {
                if (popup.closed) {
                  clearInterval(pollInterval);
                  console.log('Popup closed - checking for auth completion');
                  // Check if we got redirected back with a code
                  setTimeout(() => this.checkConnection(), 500);
                }
              }, 500);

            } else {
              console.log('Not in iframe - using direct redirect');
              // Not in iframe (localhost testing) - use direct redirect
              window.location.href = authUrl.toString();
            }

          } catch (error) {
            console.error('OAuth flow error:', error);
            this.showError(`Failed to start authentication: ${error.message}`);
          }
        }

        async handleOAuthCallback(code) {
          document.getElementById('app-content').innerHTML = `
            <div class="loading">
              <div class="spinner"></div>
              <p>Completing authentication...</p>
            </div>
          `;

          try {
            const codeVerifier = localStorage.getItem(STORAGE_KEYS.codeVerifier);
            
            if (!codeVerifier) {
              throw new Error('Code verifier not found. Please try again.');
            }

            // Exchange code for token (PKCE - no client_secret)
            const tokenRequestBody = {
              grant_type: 'authorization_code',
              client_id: OAUTH_CONFIG.clientId,
              code: code,
              code_verifier: codeVerifier,
              redirect_uri: OAUTH_CONFIG.redirectUri,
              audience: OAUTH_CONFIG.audience
            };
            
            const tokenResponse = await fetch(OAUTH_CONFIG.tokenEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(tokenRequestBody)
            });

            if (!tokenResponse.ok) {
              const errorData = await tokenResponse.json();
              throw new Error(errorData.error_description || 'Token exchange failed');
            }

            const tokenData = await tokenResponse.json();
            
            // Store tokens
            this.saveTokens(tokenData);
            this.cleanupOAuthState();

            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);

            // Show success
            document.getElementById('app-content').innerHTML = `
              <div class="success-message">
                ‚úì Successfully connected to SideDrawer!
              </div>
            `;

            // Reload to show connected status
            setTimeout(() => this.checkConnection(), 1500);

          } catch (error) {
            console.error('Token exchange error:', error);
            this.showError(`Authentication failed: ${error.message}`);
            this.cleanupOAuthState();
          }
        }

        async refreshAccessToken() {
          const refreshToken = await this.getRefreshToken();
          
          if (!refreshToken) {
            console.error('‚ùå No refresh token available for refresh');
            // Last resort: check session object directly
            const session = await this.getZohoSession();
            if (session && session.refreshToken) {
              console.log('üîÑ Found refresh token in session object, using it...');
              // Use session.refreshToken directly
              const tokenToUse = session.refreshToken;
              // Continue with refresh using this token
              try {
                console.log('üîÑ Refreshing access token...');
                const refreshRequestBody = {
                  grant_type: 'refresh_token',
                  client_id: OAUTH_CONFIG.clientId,
                  refresh_token: tokenToUse,
                  audience: OAUTH_CONFIG.audience,
                  scope: OAUTH_CONFIG.scope  // CRITICAL: Include scope to get new refresh token with rotation enabled
                };
                
                const response = await fetch(OAUTH_CONFIG.tokenEndpoint, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(refreshRequestBody)
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  console.error('‚ùå Token refresh failed:', response.status, errorText);
                  
                    
                  throw new Error(`Token refresh failed: ${response.status}`);
                }

                const tokenData = await response.json();
                console.log('‚úÖ Token refresh successful!');
                console.log('  New access token length:', tokenData.access_token?.length || 0);
                console.log('  Expires in:', tokenData.expires_in, 'seconds');
                console.log('  New refresh token provided:', !!tokenData.refresh_token);
                if (tokenData.refresh_token) {
                  console.log('  üîÑ ROTATION: New refresh token received, old token is now invalid');
                  console.log('  New refresh token preview:', tokenData.refresh_token.substring(0, 20) + '...');
                }
                this.saveTokens(tokenData);
                this.showConnectedStatus();
                return;
              } catch (error) {
                console.error('‚ùå Token refresh error:', error);
                this.showError(`Failed to refresh session: ${error.message}`, true);
                return;
              }
            }
            this.showDisconnectedStatus();
            return;
          }

          try {
            console.log('üîÑ Refreshing access token...');
            console.log('  Token endpoint:', OAUTH_CONFIG.tokenEndpoint);
            console.log('  Client ID:', OAUTH_CONFIG.clientId);
            console.log('  Refresh token:', refreshToken.substring(0, 20) + '...');
            
            const refreshRequestBody = {
              grant_type: 'refresh_token',
              client_id: OAUTH_CONFIG.clientId,
              refresh_token: refreshToken,
              audience: OAUTH_CONFIG.audience,
              scope: OAUTH_CONFIG.scope  // CRITICAL: Include scope to get new refresh token with rotation enabled
            };
            
            const response = await fetch(OAUTH_CONFIG.tokenEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(refreshRequestBody)
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('‚ùå Token refresh failed:', response.status, errorText);
              
              // Log the actual request being made for debugging
              console.log('üîç Debugging refresh request:');
              console.log('   Endpoint:', OAUTH_CONFIG.tokenEndpoint);
              console.log('   Client ID:', OAUTH_CONFIG.clientId);
              console.log('   Refresh token (full):', refreshToken);
              console.log('   Audience:', OAUTH_CONFIG.audience);
              console.log('   Request body:', JSON.stringify(refreshRequestBody, null, 2));
              
              throw new Error(`Token refresh failed: ${response.status}`);
            }

            const tokenData = await response.json();
            console.log('‚úÖ Token refresh successful!');
            console.log('  New access token length:', tokenData.access_token?.length || 0);
            console.log('  Expires in:', tokenData.expires_in, 'seconds');
            console.log('  New refresh token provided:', !!tokenData.refresh_token);
            if (tokenData.refresh_token) {
              console.log('  üîÑ ROTATION: New refresh token received, old token is now invalid');
              console.log('  New refresh token preview:', tokenData.refresh_token.substring(0, 20) + '...');
            } else {
              console.warn('  ‚ö†Ô∏è WARNING: No new refresh token in response - rotation may not be working!');
            }
            
            this.saveTokens(tokenData);
            this.showConnectedStatus();

          } catch (error) {
            console.error('‚ùå Token refresh error:', error);
            console.error('Error details:', error.stack);
            // Show disconnect option since refresh token is likely invalid
            this.showError(`Failed to refresh session: ${error.message}`, true);
            // CRITICAL: Re-throw error so caller knows refresh failed
            throw error;
          }
        }

        async testConnection() {
          const resultDiv = document.getElementById('test-result');
          resultDiv.innerHTML = `
            <div class="loading loading-padded">
              <div class="spinner"></div>
              <p>Testing connection...</p>
            </div>
          `;

          try {
            const token = await this.getAccessToken();
            
            // Test API call to SideDrawer tenant endpoint
            const response = await fetch('https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/tenant/shared', {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });

            if (response.ok) {
              const data = await response.json();
              
              if (data && data.length > 0) {
                const tenant = data[0];
                const tenantInfo = { 
                  tenantId: tenant.id || "", 
                  brandCode: tenant.defaultBrandCode || "", 
                  region: tenant.region || "" 
                };
                
                resultDiv.innerHTML = `
                  <div class="success-message">
                    ‚úì Connection test successful!
                  </div>
                  <div class="info-section info-section-spaced">
                    <strong class="info-section-title">Tenant Information:</strong>
                    <p><strong>Tenant ID:</strong> ${tenantInfo.tenantId}</p>
                    <p><strong>Brand Code:</strong> ${tenantInfo.brandCode}</p>
                    <p><strong>Region:</strong> ${tenantInfo.region}</p>
                  </div>
                  <div class="token-info token-info-spaced">
                    <strong class="token-info-title">Access Token:</strong>
                    <code class="code-block">${token}</code>
                    <button class="btn btn-small" onclick="navigator.clipboard.writeText('${token}').then(() => alert('Token copied to clipboard!'))">üìã Copy Token</button>
                  </div>
                `;
              } else {
                throw new Error('No tenant data returned');
              }
            } else {
              const errorText = await response.text().catch(() => '');
              throw new Error(`API returned ${response.status}: ${errorText}`);
            }

          } catch (error) {
            console.error('Connection test error:', error);
            resultDiv.innerHTML = `
              <div class="error-message">
                ‚úó Connection test failed: ${error.message}
              </div>
            `;
          }
        }

        async disconnect() {
          console.log('üîì Disconnecting from SideDrawer...');
          
          // Clear periodic refresh interval
          if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
            console.log('‚úì Periodic refresh stopped');
          }
          
          // Clear Zoho session
          await this.clearZohoSession();
          
          // Clear refresh token from localStorage
          localStorage.removeItem(STORAGE_KEYS.refreshToken);
          
          // Clear all Auth0 cookies (including sidedrawer_refresh_token)
          this.clearAllCookies();
          
          // Clear all localStorage items related to SideDrawer and Auth0
          Object.keys(localStorage).forEach(key => {
            if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
              localStorage.removeItem(key);
            }
          });
          
          console.log('‚úì Local session cleared');
          
          // Clear Auth0 session by redirecting to logout endpoint
          // This ensures the user will be prompted to login again
          // Dynamically use the correct Auth0 domain (sandbox or production)
          const auth0Domain = getAuth0Domain();
          const auth0LogoutUrl = `${auth0Domain}/v2/logout?client_id=${OAUTH_CONFIG.clientId}&returnTo=${encodeURIComponent(OAUTH_CONFIG.redirectUri)}`;
          
          console.log('‚úì Redirecting to Auth0 logout:', auth0Domain);
          
          // Redirect to Auth0 logout, which will then redirect back to our app
          window.location.href = auth0LogoutUrl;
        }
        
        clearAllCookies() {
          // Get all cookies
          const cookies = document.cookie.split(';');
          
          // Clear each cookie by setting expiry to past date
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i];
            const eqPos = cookie.indexOf('=');
            const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
            
            // Clear for current path and domain
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=' + window.location.hostname;
            
            // Try to clear for parent domain (e.g., .sidedrawer.com)
            const domainParts = window.location.hostname.split('.');
            if (domainParts.length > 1) {
              const parentDomain = '.' + domainParts.slice(-2).join('.');
              document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=' + parentDomain;
            }
            
            console.log('üóëÔ∏è Cleared cookie:', name);
          }
        }

        async saveTokens(tokenData) {
          // Store access token in Zoho session (shared across widgets)
          const expiresAt = Date.now() + (tokenData.expires_in * 1000);
          
          // DEBUG: Log what we received from OAuth
          console.log('üíæ Saving tokens - OAuth response contains:');
          console.log('  - access_token:', !!tokenData.access_token, tokenData.access_token ? `(${tokenData.access_token.length} chars)` : 'MISSING');
          console.log('  - refresh_token:', !!tokenData.refresh_token, tokenData.refresh_token ? `(${tokenData.refresh_token.length} chars)` : 'MISSING');
          console.log('  - expires_in:', tokenData.expires_in);
          console.log('  - token_type:', tokenData.token_type);
          console.log('  - All keys in tokenData:', Object.keys(tokenData));
          
          // Get existing refresh token (in case new one not provided)
          // Check both session object and localStorage
          const session = await this.getZohoSession();
          const existingRefreshToken = session?.refreshToken || localStorage.getItem(STORAGE_KEYS.refreshToken);
          
          console.log('üíæ Existing refresh token check:');
          console.log('  - In session object:', !!session?.refreshToken);
          console.log('  - In localStorage:', !!localStorage.getItem(STORAGE_KEYS.refreshToken));
          
          // Use new refresh token if provided, otherwise keep existing one
          const refreshTokenToUse = tokenData.refresh_token || existingRefreshToken;
          
          const sessionData = {
            accessToken: tokenData.access_token,
            expiresAt: expiresAt,
            tokenType: tokenData.token_type || 'Bearer',
            // Store refresh token in session object too (for consistency with @SidedrawerRelated)
            refreshToken: refreshTokenToUse || null
          };
          
          console.log('üíæ Saving session data...');
          console.log('  Access token length:', tokenData.access_token?.length || 0);
          console.log('  Expires at:', new Date(expiresAt).toISOString());
          console.log('  Refresh token in session:', !!sessionData.refreshToken);
          if (sessionData.refreshToken) {
            console.log('  Refresh token preview:', sessionData.refreshToken.substring(0, 20) + '...');
          }
          
          await this.setZohoSession(sessionData);
          
          // Store refresh token in localStorage (persistent) - ALWAYS save if we have one
          if (refreshTokenToUse) {
            localStorage.setItem(STORAGE_KEYS.refreshToken, refreshTokenToUse);
            console.log('‚úÖ Refresh token stored in localStorage:', STORAGE_KEYS.refreshToken);
            console.log('‚úÖ Refresh token also stored in session object');
          } else {
            console.error('‚ùå CRITICAL: No refresh token available to store!');
            console.error('  - OAuth response had refresh_token:', !!tokenData.refresh_token);
            console.error('  - Existing refresh token found:', !!existingRefreshToken);
            console.error('  - This means session cannot be refreshed automatically!');
            console.error('  - User will need to re-authenticate when token expires.');
          }
        }

        async getAccessToken() {
          const session = await this.getZohoSession();
          return session ? session.accessToken : null;
        }

        async getRefreshToken() {
          // PRIORITY 1: Check session object (new format - refresh token stored in session)
          const session = await this.getZohoSession();
          console.log('[getRefreshToken] Checking session object:', {
            hasSession: !!session,
            hasRefreshToken: !!(session?.refreshToken),
            sessionKeys: session ? Object.keys(session) : []
          });
          
          if (session && session.refreshToken) {
            console.log('‚úÖ Refresh token found in session object');
            return session.refreshToken;
          }
          
          // PRIORITY 2: Check legacy localStorage location (for backward compatibility)
          const legacyToken = localStorage.getItem(STORAGE_KEYS.refreshToken);
          console.log('[getRefreshToken] Checking legacy localStorage:', {
            key: STORAGE_KEYS.refreshToken,
            found: !!legacyToken
          });
          
          if (legacyToken) {
            console.log('‚úÖ Refresh token found in legacy localStorage');
            return legacyToken;
          }
          
          // PRIORITY 3: Check all localStorage keys containing "refresh" or "token"
          console.log('[getRefreshToken] Scanning localStorage for refresh tokens...');
          const allKeys = Object.keys(localStorage);
          const tokenKeys = allKeys.filter(k => k.toLowerCase().includes('refresh') || k.toLowerCase().includes('token'));
          console.log('[getRefreshToken] Found potential token keys:', tokenKeys);
          tokenKeys.forEach(key => {
            const value = localStorage.getItem(key);
            console.log(`  - ${key}: ${value ? value.substring(0, 20) + '...' : 'empty'}`);
          });
          
          console.log('‚ö†Ô∏è No refresh token found in session object or localStorage');
          return null;
        }

        isTokenExpired(expiresAt) {
          if (!expiresAt) return true;
          // Add 5 minute buffer before expiry
          const bufferTime = 5 * 60 * 1000;
          return Date.now() >= (parseInt(expiresAt) - bufferTime);
        }

        cleanupOAuthState() {
          localStorage.removeItem(STORAGE_KEYS.codeVerifier);
        }

        // PKCE Helper Functions
        generateCodeVerifier() {
          const array = new Uint8Array(32);
          crypto.getRandomValues(array);
          return this.base64UrlEncode(array);
        }

        async generateCodeChallenge(codeVerifier) {
          const encoder = new TextEncoder();
          const data = encoder.encode(codeVerifier);
          const hash = await crypto.subtle.digest('SHA-256', data);
          return this.base64UrlEncode(new Uint8Array(hash));
        }

        base64UrlEncode(array) {
          return btoa(String.fromCharCode.apply(null, array))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
        }

        generateRandomString(length) {
          const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          let result = '';
          for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          return result;
        }
      }

      // Tenant Creation Wizard, StripeService, and TenantCreationWizard classes are in tenant-wizard.js
      const auth = new SideDrawerAuth();
      
      // Helper function to check session status (can be called from console)
      window.checkSideDrawerSession = async function() {
        console.log('üîç Checking SideDrawer Session Status...');
        console.log('='.repeat(60));
        
        // Check localStorage for session
        const sessionStr = localStorage.getItem('sdSession');
        console.log('üì¶ localStorage key "sdSession":', sessionStr ? 'FOUND' : 'NOT FOUND');
        
        if (sessionStr) {
          try {
            const session = JSON.parse(sessionStr);
            console.log('‚úÖ Session object parsed successfully');
            console.log('  Keys in session:', Object.keys(session));
            console.log('  Has accessToken:', !!session.accessToken);
            console.log('  Has refreshToken:', !!session.refreshToken);
            console.log('  Expires at:', session.expiresAt ? new Date(parseInt(session.expiresAt)).toISOString() : 'N/A');
            
            if (session.expiresAt) {
              const now = Date.now();
              const expiresAt = parseInt(session.expiresAt);
              const timeUntilExpiry = Math.floor((expiresAt - now) / 1000);
              console.log('  Time until expiry:', timeUntilExpiry, 'seconds');
              console.log('  Is expired:', timeUntilExpiry < 0 ? 'YES ‚ùå' : 'NO ‚úÖ');
            }
            
            if (session.refreshToken) {
              console.log('  Refresh token preview:', session.refreshToken.substring(0, 20) + '...');
            } else {
              console.log('  ‚ö†Ô∏è NO REFRESH TOKEN IN SESSION OBJECT!');
            }
          } catch (e) {
            console.error('‚ùå Failed to parse session:', e);
          }
        }
        
        // Check localStorage for separate refresh token
        const refreshTokenKey = 'sidedrawer_refresh_token';
        const refreshToken = localStorage.getItem(refreshTokenKey);
        console.log('üì¶ localStorage key "' + refreshTokenKey + '":', refreshToken ? 'FOUND ‚úÖ' : 'NOT FOUND ‚ùå');
        if (refreshToken) {
          console.log('  Refresh token preview:', refreshToken.substring(0, 20) + '...');
        }
        
        // Check sessionStorage
        const sessionStorageStr = sessionStorage.getItem('sdSession');
        console.log('üì¶ sessionStorage key "sdSession":', sessionStorageStr ? 'FOUND' : 'NOT FOUND');
        
        console.log('='.repeat(60));
        
        if (!sessionStr || !refreshToken) {
          console.log('‚ö†Ô∏è NO REFRESH TOKEN FOUND!');
          console.log('');
          console.log('üìã This means:');
          console.log('  1. Your session was created BEFORE refresh token storage was added');
          console.log('  2. OR the OAuth response did not include refresh_token');
          console.log('  3. Session cannot be automatically refreshed');
          console.log('');
          console.log('‚úÖ SOLUTION: Re-authenticate to get a fresh session with refresh token');
          console.log('  - Click "Connect to SideDrawer" button in the widget');
          console.log('  - OR run: auth.startOAuthFlow()');
          console.log('');
          console.log('‚úÖ After re-authentication, refresh token will be stored in:');
          console.log('  - Session object: sdSession.refreshToken');
          console.log('  - localStorage: sidedrawer_refresh_token');
        } else {
          console.log('‚úÖ Refresh token found! Session can be automatically refreshed.');
          console.log('üí° Run: auth.checkConnection() to test refresh');
        }
      };
      
      console.log('üí° Run checkSideDrawerSession() in console to check session status');
    </script>
  </body>
</html>
