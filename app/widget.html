<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SideDrawer Integration</title>
    <!-- Zoho CRM SDK -->
    <script src="https://live.zwidgets.com/js-sdk/1.2/ZohoEmbededAppSDK.min.js"></script>
    <!-- Stripe.js for PCI-compliant payment processing -->
    <script src="https://js.stripe.com/v3/"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
        background: #f9fafb;
        padding: 20px;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        padding: 40px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        color: #1f2937;
        font-size: 30px;
        font-weight: 700;
        margin-bottom: 8px;
      }

      .header p {
        color: #6b7280;
        font-size: 15px;
        font-weight: 400;
      }

      .status-card {
        background: #f9fafb;
        border-radius: 6px;
        padding: 24px;
        margin-bottom: 24px;
        border-left: 4px solid #1e88e5;
      }

      .status-card.connected {
        border-left-color: #10b981;
        background: #d1fae5;
      }

      .status-card.error {
        border-left-color: #dc2626;
        background: #fef2f2;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #95a5a6;
      }

      .status-dot.connected {
        display: none; /* Hide the dot when connected, text has bullet point */
      }

      .status-dot.error {
        background: #e74c3c;
      }

      .status-text {
        font-weight: 600;
        color: #1f2937;
        font-size: 17px;
      }

      .status-card.connected .status-text {
        font-weight: 700;
        color: #064e3b;
      }

      /* Stripe Elements Styles */
      .stripe-card-element-container {
        padding: 12px;
        border: 1px solid rgba(0, 0, 0, 0.12);
        border-radius: 4px;
        background-color: #fff;
        transition: border-color 0.2s;
        margin-bottom: 16px;
      }

      .stripe-card-element-container:focus-within {
        border-color: #ff6b35;
        box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.1);
      }

      .stripe-error {
        color: #df1b41;
        font-size: 14px;
        margin-top: 8px;
        display: none;
      }

      .stripe-error.show {
        display: block;
      }

      /* Tenant Creation Wizard Styles */
      .tenant-wizard {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        padding: 40px;
      }

      .wizard-header {
        text-align: center;
        margin-bottom: 40px;
      }

      .wizard-header h1 {
        color: #1f2937;
        font-size: 28px;
        font-weight: 700;
        margin-bottom: 8px;
      }

      .wizard-header p {
        color: #6b7280;
        font-size: 15px;
      }

      .wizard-stepper {
        display: flex;
        justify-content: space-between;
        margin-bottom: 40px;
        position: relative;
      }

      .wizard-stepper::before {
        content: '';
        position: absolute;
        top: 20px;
        left: 0;
        right: 0;
        height: 2px;
        background: #e5e7eb;
        z-index: 0;
      }

      .wizard-step {
        flex: 1;
        position: relative;
        z-index: 1;
        text-align: center;
      }

      .wizard-step-circle {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #e5e7eb;
        color: #6b7280;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 8px;
        font-weight: 600;
        font-size: 16px;
        transition: all 0.3s;
      }

      .wizard-step.active .wizard-step-circle {
        background: #ff6b35;
        color: white;
      }

      .wizard-step.completed .wizard-step-circle {
        background: #10b981;
        color: white;
      }

      .wizard-step-label {
        font-size: 14px;
        color: #6b7280;
        font-weight: 500;
      }

      .wizard-step.active .wizard-step-label {
        color: #1f2937;
        font-weight: 600;
      }

      .wizard-content {
        min-height: 400px;
        margin-bottom: 30px;
      }

      .wizard-form-group {
        margin-bottom: 24px;
      }

      .wizard-form-label {
        display: block;
        margin-bottom: 8px;
        color: #374151;
        font-weight: 600;
        font-size: 14px;
      }

      .wizard-form-input {
        width: 100%;
        padding: 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 15px;
        transition: border-color 0.2s;
      }

      .wizard-form-input:focus {
        outline: none;
        border-color: #ff6b35;
        box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1);
      }

      .wizard-form-error {
        color: #dc2626;
        font-size: 13px;
        margin-top: 4px;
        display: none;
      }

      .wizard-form-error.show {
        display: block;
      }

      .wizard-form-select {
        width: 100%;
        padding: 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 15px;
        background: white;
        cursor: pointer;
      }

      .wizard-footer {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        padding-top: 24px;
        border-top: 1px solid #e5e7eb;
      }

      .wizard-footer button {
        flex: 1;
      }

      .price-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
        margin-top: 20px;
      }

      .price-card {
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
      }

      .price-card:hover {
        border-color: #ff6b35;
        box-shadow: 0 4px 12px rgba(255, 107, 53, 0.15);
      }

      .price-card.selected {
        border-color: #ff6b35;
        background: #fff5f2;
      }

      .toggle-button-group {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .toggle-button {
        flex: 1;
        padding: 10px 16px;
        border: 2px solid #e5e7eb;
        border-radius: 6px;
        background: white;
        color: #374151;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .toggle-button:hover {
        border-color: #ff6b35;
      }

      .toggle-button.active {
        border-color: #ff6b35;
        background: #fff5f2;
        color: #ff6b35;
      }

      .tenant-creation-form-price-section {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .tenant-creation-form-price-section-currency h4,
      .tenant-creation-form-price-section-users h4,
      .tenant-creation-form-price-section-price h4 {
        margin: 0 0 8px 0;
        font-size: 14px;
        font-weight: 600;
        color: #374151;
      }

      .tenant-creation-form-price-section-price-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 12px;
      }

      .app-tenant-creation-form-price-card {
        cursor: pointer;
      }

      .selectable-price-card {
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        padding: 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.2s;
        background: white;
      }

      .selectable-price-card:hover {
        border-color: #ff6b35;
      }

      .selectable-price-card.active {
        border-color: #ff6b35;
        background: #fff5f2;
      }

      .selectable-price-card-content {
        flex: 1;
      }

      .selectable-price-card-name {
        font-size: 16px;
        font-weight: 600;
        color: #111827;
        margin-bottom: 8px;
      }

      .selectable-price-card-price {
        font-size: 14px;
        color: #374151;
      }

      .selectable-price-card-currency {
        margin-left: 4px;
        color: #6b7280;
      }

      .selectable-price-card-unit {
        margin-left: 4px;
        color: #6b7280;
      }

      .selectable-price-card-checkmark {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #ff6b35;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
      }

      .tenant-creation-form-price-selected-resume {
        max-width: 600px;
        margin: 0 auto;
      }

      .tenant-creation-form-price-selected-resume-title {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .tenant-creation-form-price-selected-resume-title h2 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
        color: #111827;
      }

      .tenant-creation-form-price-selected-chip {
        background: var(--primaryColor);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
      }

      .tenant-creation-form-price-selected-chip p {
        margin: 0;
      }

      .tenant-creation-form-price-selected-price {
        font-size: 18px;
        color: #111827;
        margin-bottom: 16px;
      }

      .tenant-creation-form-price-selected-list-price {
        text-decoration: line-through;
        color: #9ca3af;
        margin-right: 8px;
      }

      .tenant-creation-form-price-selected-features-description {
        color: #6b7280;
        margin-bottom: 16px;
      }

      .tenant-creation-form-price-selected-features {
        list-style: none;
        padding: 0;
        margin: 0 0 12px 0;
      }

      .tenant-creation-form-price-selected-features li {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        color: #374151;
      }

      .tenant-creation-form-price-selected-features-button {
        margin-bottom: 24px;
      }

      .tenant-creation-form-price-selected-resume-section-title {
        font-size: 16px;
        font-weight: 600;
        color: #111827;
        margin: 0 0 16px 0;
      }

      .tenant-creation-form-price-selected-resume-section-line {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 12px;
      }

      .tenant-creation-form-price-selected-resume-section-line-title {
        font-size: 14px;
        color: #374151;
      }

      .tenant-creation-form-price-selected-resume-section-line-amount {
        font-size: 14px;
        font-weight: 600;
        color: #111827;
        text-align: right;
      }

      .tenant-creation-form-price-selected-resume-section-line-description {
        font-size: 12px;
        color: #6b7280;
        margin: 4px 0 0 0;
        width: 100%;
      }

      .tenant-creation-form-price-selected-total-section-line {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-top: 16px;
      }

      .tenant-creation-form-price-selected-total-section-line-title {
        font-size: 16px;
        font-weight: 600;
        color: #111827;
      }

      .tenant-creation-form-price-selected-total-section-line-amount {
        font-size: 18px;
        font-weight: 700;
        color: var(--primaryColor);
      }

      .tenant-creation-form-price-selected-total-section-line-description {
        font-size: 12px;
        color: #6b7280;
        margin: 4px 0 0 0;
        width: 100%;
      }

      .price-card-name {
        font-weight: 600;
        font-size: 16px;
        color: #1f2937;
        margin-bottom: 8px;
      }

      .price-card-amount {
        font-size: 24px;
        font-weight: 700;
        color: #ff6b35;
        margin-bottom: 4px;
      }

      .price-card-interval {
        color: #6b7280;
        font-size: 14px;
      }

      .price-card-icon {
        margin: 0 auto 12px;
      }

      .price-card-currency {
        font-size: 16px;
        font-weight: 400;
        margin-left: 4px;
        color: #6b7280;
      }

      .price-card-unit {
        color: #6b7280;
        font-size: 12px;
        margin-top: 4px;
      }

      .currency-selector {
        margin-bottom: 24px;
      }

      .currency-display {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        cursor: pointer;
        background: white;
      }

      .currency-display:hover {
        border-color: #ff6b35;
      }

      .billing-address-section {
        margin-top: 24px;
        padding: 20px;
        background: #f9fafb;
        border-radius: 8px;
      }

      .validation-error {
        background: #fef2f2;
        border: 1px solid #fecaca;
        color: #991b1b;
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 16px;
        font-size: 14px;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }

      .loading-content {
        background: white;
        padding: 40px;
        border-radius: 8px;
        text-align: center;
      }

      .success-animation {
        text-align: center;
        padding: 40px;
      }

      .success-icon {
        width: 80px;
        height: 80px;
        margin: 0 auto 20px;
        background: #10b981;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        color: white;
      }

      /* Modal/Dialog Styles (matching Angular Material) */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.2s;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .modal-dialog {
        background: white;
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow: auto;
        animation: slideUp 0.3s;
      }

      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid #e5e7eb;
      }

      .modal-title {
        font-size: 20px;
        font-weight: 600;
        color: #1f2937;
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 24px;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background 0.2s;
      }

      .modal-close:hover {
        background: #f3f4f6;
      }

      .modal-body {
        padding: 24px;
      }

      .modal-description {
        color: #6b7280;
        font-size: 14px;
        margin-bottom: 20px;
      }

      .currency-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .currency-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .currency-item:hover {
        border-color: #ff6b35;
        background: #fff5f2;
      }

      .currency-item.selected {
        border-color: #ff6b35;
        background: #fff5f2;
      }

      .currency-flag {
        width: 32px;
        height: 24px;
        border-radius: 4px;
        object-fit: cover;
      }

      .currency-info {
        flex: 1;
      }

      .currency-iso {
        font-weight: 600;
        color: #1f2937;
        font-size: 15px;
      }

      .currency-name {
        color: #6b7280;
        font-size: 13px;
      }

      .currency-check {
        color: #ff6b35;
        font-size: 20px;
        font-weight: bold;
      }

      .billing-address-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .btn {
        display: inline-block;
        padding: 11px 20px;
        background: #f3f4f6;
        color: #374151;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        text-decoration: none;
      }

      .btn:hover {
        background: #e5e7eb;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.btn-success {
        background: #FF8C42;
        color: white;
        border-color: #FF8C42;
      }

      .btn.btn-success:hover {
        background: #ff7a28;
        border-color: #ff7a28;
      }

      .info-section {
        margin-top: 20px;
        padding: 20px;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        font-size: 14px;
        color: #4b5563;
        line-height: 1.6;
      }

      .info-section strong {
        color: #111827;
        font-weight: 600;
      }

      .info-section p {
        margin: 8px 0;
      }

      .loading {
        text-align: center;
        padding: 40px;
        color: #6b7280;
      }

      .spinner {
        border: 3px solid #e5e7eb;
        border-top: 3px solid #1e88e5;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .error-message {
        background: #fef2f2;
        border: 1px solid #fca5a5;
        color: #991b1b;
        padding: 16px;
        border-radius: 6px;
        margin-top: 15px;
        font-size: 14px;
      }

      .success-message {
        background: #ecfdf5;
        border: 1px solid #86efac;
        color: #065f46;
        padding: 16px;
        border-radius: 6px;
        margin-top: 15px;
        font-size: 14px;
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .token-info {
        margin-top: 15px;
        padding: 16px;
        background: #f9fafb;
        border-radius: 6px;
        font-size: 13px;
        color: #6b7280;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>SideDrawer Integration</h1>
        <p>Connect your Zoho CRM with SideDrawer</p>
      </div>

      <div id="app-content">
        <div class="loading">
          <div class="spinner"></div>
          <p>Initializing connection...</p>
        </div>
      </div>
      
      <!-- Tenant Creation Wizard Container (hidden by default) -->
      <div id="tenant-wizard" style="display: none;"></div>
    </div>

      <script>
      // Read URL parameters for initial config
      const urlParams = new URLSearchParams(window.location.search);
      const isOAuthCallback = urlParams.has('code') || urlParams.has('error');
      
      // Helper to get config param (from URL or sessionStorage)
      function getConfigParam(key) {
        // If URL has param, use and store it
        if (urlParams.has(key)) {
          const value = urlParams.get(key);
          if (!isOAuthCallback) {
            sessionStorage.setItem('sd_config_' + key, value);
          }
          return value;
        }
        // Otherwise try sessionStorage
        return sessionStorage.getItem('sd_config_' + key) || null;
      }
      
      // OAuth2 Configuration (will be updated with Zoho config if available)
      const OAUTH_CONFIG = {
        authorizationEndpoint: 'https://auth-sbx.sidedrawersbx.com/authorize',
        tokenEndpoint: 'https://auth-sbx.sidedrawersbx.com/oauth/token',
        clientId: getConfigParam('client_id') || null,
        audience: 'https://user-api-sbx.sidedrawersbx.com',
        redirectUri: getConfigParam('redirect_uri') || (window.location.origin + window.location.pathname.split('?')[0]),
        scope: 'openid profile email offline_access'
      };
      
      // Log initial configuration
      console.log('üîß Initial OAuth Config (PKCE - NO CLIENT SECRET):');
      console.log('  Client ID:', OAUTH_CONFIG.clientId ? 'Set' : 'NOT SET');
      console.log('  Redirect URI:', OAUTH_CONFIG.redirectUri);
      console.log('  Is OAuth Callback:', isOAuthCallback);

      // Storage keys
      const STORAGE_KEYS = {
        refreshToken: 'sidedrawer_refresh_token', // Persistent in localStorage
        codeVerifier: 'sidedrawer_code_verifier'
      };

      const ZOHO_SESSION_KEY = 'sdSession'; // Zoho session storage key
      
      // Helper function to extract Auth0 domain from authorization endpoint
      function getAuth0Domain() {
        try {
          const url = new URL(OAUTH_CONFIG.authorizationEndpoint);
          return url.origin; // Returns https://auth-sbx.sidedrawersbx.com or https://auth.sidedrawer.com
        } catch (e) {
          console.error('Failed to parse Auth0 domain:', e);
          return 'https://auth-sbx.sidedrawersbx.com'; // Fallback to sandbox
        }
      }

      class SideDrawerAuth {
        constructor() {
          this.zohoInitialized = false;
          this.refreshInterval = null;
          this.initZoho();
        }

        async initZoho() {
          // Helper function to extract client_id from sd_config_redirect_uri sessionStorage
          const extractClientIdFromRedirectUri = () => {
            const redirectUri = sessionStorage.getItem('sd_config_redirect_uri');
            if (redirectUri) {
              try {
                const url = new URL(redirectUri);
                const clientId = url.searchParams.get('client_id');
                if (clientId) {
                  console.log('[SideDrawer Widget] ‚úì Extracted client_id from redirect_uri:', clientId);
                  return clientId;
                }
              } catch (e) {
                console.warn('[SideDrawer Widget] Failed to parse redirect_uri:', e);
              }
            }
            return null;
          };
          
          // Helper function to get client_id from multiple sources
          const getClientId = () => {
            // Priority 1: URL params
            const urlClientId = urlParams.get('client_id');
            if (urlClientId) {
              return urlClientId;
            }
            
            // Priority 2: Extract from sd_config_redirect_uri
            const redirectUriClientId = extractClientIdFromRedirectUri();
            if (redirectUriClientId) {
              return redirectUriClientId;
            }
            
            // Priority 3: From OAUTH_CONFIG (which may have been set from sessionStorage)
            if (OAUTH_CONFIG.clientId) {
              return OAUTH_CONFIG.clientId;
            }
            
            return null;
          };
          
          // When loaded in Zoho, respond to postMessage requests for session data
          window.addEventListener('message', async (event) => {
            // Handle REFRESH_SIDEDRAWER_TOKEN message
            if (event.data && event.data.type === 'REFRESH_SIDEDRAWER_TOKEN') {
              console.log('[SideDrawer Widget] üîÑ Received token refresh request');
              
              try {
                // Get client_id from multiple sources
                const clientId = getClientId();
                
                if (!clientId) {
                  throw new Error('client_id not found in URL params, redirect_uri, or sessionStorage');
                }
                
                // Update OAUTH_CONFIG.clientId if needed
                if (!OAUTH_CONFIG.clientId) {
                  OAUTH_CONFIG.clientId = clientId;
                  console.log('[SideDrawer Widget] ‚úì Set OAUTH_CONFIG.clientId from getClientId():', clientId);
                }
                
                console.log('[SideDrawer Widget] Client ID for refresh:', clientId);
                
                // Call the existing refreshAccessToken method
                await this.refreshAccessToken();
                
                // Get the refreshed session
                const refreshedSession = await this.getZohoSession();
                
                if (refreshedSession && refreshedSession.accessToken) {
                  // Ensure clientId is in session
                  if (!refreshedSession.clientId) {
                    refreshedSession.clientId = clientId;
                  }
                  
                  console.log('[SideDrawer Widget] ‚úÖ Token refreshed successfully');
                  console.log('[SideDrawer Widget] New token expires at:', refreshedSession.expiresAt ? new Date(parseInt(refreshedSession.expiresAt)).toISOString() : 'N/A');
                  
                  // Send refreshed session back to parent
                  window.parent.postMessage({
                    type: 'SIDEDRAWER_SESSION_RESPONSE',
                    session: refreshedSession
                  }, '*');
                } else {
                  throw new Error('Failed to get refreshed session after token refresh');
                }
                
              } catch (error) {
                console.error('[SideDrawer Widget] ‚ùå Token refresh error:', error);
                window.parent.postMessage({
                  type: 'SIDEDRAWER_SESSION_RESPONSE',
                  session: null,
                  error: error.message
                }, '*');
              }
              
              return; // Exit early, don't process REQUEST_SIDEDRAWER_SESSION
            }
            
            // Handle REQUEST_SIDEDRAWER_SESSION message
            if (event.data && event.data.type === 'REQUEST_SIDEDRAWER_SESSION') {
              console.log('üì• Received session request from parent window');
              const session = localStorage.getItem('sdSession');
              if (session) {
                try {
                  const sessionData = JSON.parse(session);
                  
                  // Ensure clientId is in session (extract from multiple sources if missing)
                  if (!sessionData.clientId) {
                    const clientId = getClientId();
                    if (clientId) {
                      sessionData.clientId = clientId;
                      // Update stored session with clientId
                      localStorage.setItem('sdSession', JSON.stringify(sessionData));
                    }
                  }
                  
                  window.parent.postMessage({
                    type: 'SIDEDRAWER_SESSION_RESPONSE',
                    session: sessionData
                  }, '*');
                  console.log('üì§ Sent session to parent window');
                } catch (e) {
                  console.error('Failed to parse/send session:', e);
                }
              } else {
                console.log('‚ö† No session available to send');
                // Send null session response
                window.parent.postMessage({
                  type: 'SIDEDRAWER_SESSION_RESPONSE',
                  session: null
                }, '*');
              }
            }
          });
          
          console.log('‚úÖ Session bridge ready (localStorage only, no Zoho SDK needed)');
          
          try {
            // Set up message listener for OAuth popup callback
            window.addEventListener('message', async (event) => {
              console.log('üì® Parent received message:', event.data?.type || 'unknown');
              
              // Verify origin for security
              if (event.origin !== window.location.origin) {
                console.warn('‚ö† Ignoring message from different origin:', event.origin);
                return;
              }
              
              if (event.data && event.data.type === 'SIDEDRAWER_OAUTH_TOKENS') {
                console.log('‚úÖ Received OAuth tokens from popup');
                console.log('Has access_token:', !!event.data.tokens?.access_token);
                console.log('Has refresh_token:', !!event.data.tokens?.refresh_token);
                
                // Show processing message
                document.getElementById('app-content').innerHTML = `
                  <div class="loading">
                    <div class="spinner"></div>
                    <p>Saving authentication...</p>
                  </div>
                `;
                
                try {
                  // Save the tokens
                  await this.saveTokens(event.data.tokens);
                  console.log('‚úÖ Tokens saved successfully');
                  
                  // Show connected status
                  await this.checkConnection();
                } catch (error) {
                  console.error('‚ùå Failed to save tokens:', error);
                  this.showError(`Failed to save authentication: ${error.message}`);
                }
              } else if (event.data && event.data.type === 'SIDEDRAWER_OAUTH_ERROR') {
                console.error('‚ùå OAuth error from popup:', event.data.error);
                this.showError(`Authentication failed: ${event.data.error}`);
              }
            });

            // Initialize after Zoho setup (or fallback)
            console.log('Proceeding with initialization (Zoho initialized:', this.zohoInitialized, ')');
            console.log('OAuth Redirect URI:', OAUTH_CONFIG.redirectUri);
            this.init();
          } catch (error) {
            console.error('Initialization error:', error);
          }
        }

        async loadZohoConfig() {
          try {
            // Get widget variables from Zoho CRM
            const config = await ZOHO.CRM.CONFIG.getVariables();
            
            if (config) {
              console.log('‚úì Loaded Zoho widget variables:', Object.keys(config));
              
              // Redirect URI (REQUIRED in production)
              if (config.redirect_uri && config.redirect_uri.trim()) {
                OAUTH_CONFIG.redirectUri = config.redirect_uri.trim();
                console.log('‚úì Using configured redirect URI:', OAUTH_CONFIG.redirectUri);
              } else {
                console.warn('‚ö† No redirect URI configured - using auto-detection (may not work behind proxies)');
                console.log('Current URL:', OAUTH_CONFIG.redirectUri);
              }
              
                // Client ID (can also come from URL params)
                if (config.client_id && config.client_id.trim()) {
                  OAUTH_CONFIG.clientId = config.client_id.trim();
                  console.log('‚úì Client ID loaded from Zoho config');
                }
              
              // Environment (REQUIRED)
              if (config.environment === 'production') {
                OAUTH_CONFIG.authorizationEndpoint = 'https://auth.sidedrawer.com/authorize';
                OAUTH_CONFIG.tokenEndpoint = 'https://auth.sidedrawer.com/oauth/token';
                OAUTH_CONFIG.audience = 'https://user-api.sidedrawer.com';
                console.log('‚úì Using PRODUCTION environment');
              } else if (config.environment === 'sandbox') {
                // Already set to sandbox by default
                console.log('‚úì Using SANDBOX environment');
              } else {
                console.warn('‚ö† No environment configured - using sandbox (default)');
              }
            } else {
              console.warn('‚ö† No Zoho configuration found - using defaults (development mode)');
            }
          } catch (error) {
            console.warn('‚ö† Could not load Zoho config, using defaults (development mode):', error.message);
          }
        }

        // Simple localStorage-only session management
        async setZohoSession(data) {
          localStorage.setItem(ZOHO_SESSION_KEY, JSON.stringify(data));
          console.log('‚úì Stored session in localStorage');
          return true;
        }

        async getZohoSession() {
          const data = localStorage.getItem(ZOHO_SESSION_KEY);
          return data ? JSON.parse(data) : null;
        }

        async clearZohoSession() {
          localStorage.removeItem(ZOHO_SESSION_KEY);
          console.log('‚úì Cleared session from localStorage');
        }

        async init() {
          // Check if we're returning from OAuth redirect
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get('code');
          const error = urlParams.get('error');

          // Check if we're in a popup window opened for OAuth
          const isPopup = window.opener && !window.opener.closed;

          if (error) {
            if (isPopup) {
              // Close popup and let parent handle error
              window.close();
            } else {
              this.showError(`Authentication error: ${error}`);
              this.cleanupOAuthState();
            }
            return;
          }

          if (code) {
            if (isPopup) {
              // We're in the OAuth popup - exchange code for tokens and pass to parent
              console.log('üîê OAuth popup: Received authorization code');
              console.log('Code:', code.substring(0, 20) + '...');
              
              // Show loading in popup
              document.getElementById('app-content').innerHTML = `
                <div class="loading">
                  <div class="spinner"></div>
                  <p>Completing authentication...</p>
                  <p style="font-size: 12px; color: #666; margin-top: 10px;">This window will close automatically...</p>
                </div>
              `;
              
              try {
                // IMPORTANT: Try state parameter FIRST (most reliable, can't be stale)
                let codeVerifier = null;
                const state = urlParams.get('state');
                console.log('üîç State parameter from URL:', state ? state.substring(0, 50) + '...' : 'NOT FOUND');
                
                if (state) {
                  try {
                    const decoded = atob(state);
                    console.log('üîç Decoded state:', decoded);
                    const stateData = JSON.parse(decoded);
                    console.log('üîç Parsed state data:', stateData);
                    codeVerifier = stateData.verifier;
                    console.log('‚úÖ Code verifier from state parameter:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                  } catch (e) {
                    console.warn('‚ö† Could not parse state parameter:', e);
                    console.error('State parsing error details:', e.stack);
                  }
                }
                
                // Fallback to localStorage only if state failed
                if (!codeVerifier) {
                  codeVerifier = localStorage.getItem(STORAGE_KEYS.codeVerifier);
                  console.log('Code verifier from localStorage:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                }
                
                // Last resort: sessionStorage
                if (!codeVerifier) {
                  codeVerifier = sessionStorage.getItem(STORAGE_KEYS.codeVerifier);
                  console.log('Code verifier from sessionStorage:', codeVerifier ? codeVerifier.substring(0, 10) + '...' : 'NOT FOUND');
                }
                
                if (!codeVerifier) {
                  throw new Error('Code verifier not found in localStorage, sessionStorage, or state parameter');
                }
                
                console.log('‚úì Code verifier found, exchanging code for tokens...');
                console.log('Code verifier length:', codeVerifier.length);
                console.log('Code verifier sample:', codeVerifier.substring(0, 20) + '...' + codeVerifier.substring(codeVerifier.length - 10));
                console.log('Token endpoint:', OAUTH_CONFIG.tokenEndpoint);
                console.log('Client ID:', OAUTH_CONFIG.clientId);
                console.log('Redirect URI:', OAUTH_CONFIG.redirectUri);

                const tokenRequestBody = {
                  grant_type: 'authorization_code',
                  client_id: OAUTH_CONFIG.clientId,
                  code: code,
                  code_verifier: codeVerifier,
                  redirect_uri: OAUTH_CONFIG.redirectUri,
                  audience: OAUTH_CONFIG.audience
                };

                const tokenResponse = await fetch(OAUTH_CONFIG.tokenEndpoint, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(tokenRequestBody)
                });

                console.log('Token response status:', tokenResponse.status, tokenResponse.statusText);

                if (!tokenResponse.ok) {
                  const responseText = await tokenResponse.text();
                  console.error('‚ùå Token exchange error response (raw):', responseText);
                  let errorData;
                  try {
                    errorData = JSON.parse(responseText);
                  } catch (e) {
                    errorData = { error: 'Parse error', raw: responseText };
                  }
                  console.error('‚ùå Token exchange error (parsed):', errorData);
                  throw new Error(errorData.error_description || errorData.error || `Token exchange failed: ${tokenResponse.status}`);
                }

                const tokenData = await tokenResponse.json();
                console.log('‚úÖ Token exchange successful!');
                console.log('Has access_token:', !!tokenData.access_token);
                console.log('Has refresh_token:', !!tokenData.refresh_token);
                console.log('Expires in:', tokenData.expires_in);
                
                // Show success message in popup
                document.getElementById('app-content').innerHTML = `
                  <div class="success-message">
                    ‚úì Authentication successful!
                    <br><small>Closing window...</small>
                  </div>
                `;
                
                // Send tokens to parent window
                if (window.opener && !window.opener.closed) {
                  console.log('Sending tokens to parent window...');
                  window.opener.postMessage({ 
                    type: 'SIDEDRAWER_OAUTH_TOKENS',
                    tokens: tokenData
                  }, window.location.origin);
                  console.log('‚úÖ Tokens sent to parent');
                } else {
                  console.warn('‚ö† Parent window not available');
                }
                
                // Clean up and close
                localStorage.removeItem(STORAGE_KEYS.codeVerifier);
                sessionStorage.removeItem(STORAGE_KEYS.codeVerifier);
                setTimeout(() => {
                  console.log('Closing popup...');
                  window.close();
                }, 1000);
                
              } catch (error) {
                console.error('‚ùå OAuth popup error:', error);
                console.error('Error details:', error.stack);
                
                // Show error message in popup
                document.getElementById('app-content').innerHTML = `
                  <div class="error-message">
                    ‚úó Authentication failed
                    <br><small>${error.message}</small>
                    <br><small style="margin-top: 10px; display: block;">Check browser console for details. Window will close in 5 seconds...</small>
                  </div>
                `;
                
                // Send error to parent
                if (window.opener && !window.opener.closed) {
                  window.opener.postMessage({ 
                    type: 'SIDEDRAWER_OAUTH_ERROR',
                    error: error.message
                  }, window.location.origin);
                }
                setTimeout(() => window.close(), 5000);
              }
              return;
            } else {
              // Normal flow (not in popup) - handle callback directly
              await this.handleOAuthCallback(code);
              return;
            }
          }

          // Check existing token
          const hasSession = await this.checkConnection();
          
          // If no session and no OAuth config, show tenant creation flow
          if (!hasSession && !OAUTH_CONFIG.clientId) {
            await this.showTenantCreationFlow();
          }
        }

        async checkConnection() {
          // Try to get existing session
          const session = await this.getZohoSession();
          const refreshToken = await this.getRefreshToken();
          
          // Check if session exists and token is valid
          if (session && session.accessToken && !this.isTokenExpired(session.expiresAt)) {
            // Valid session exists - check if tenant exists
            console.log('‚úì Valid session found');
            const hasTenant = await this.checkTenantExists();
            if (!hasTenant) {
              // No tenant - show creation flow
              await this.showTenantCreationFlow();
              return false;
            }
            this.showConnectedStatus();
            return true;
          } else if (session && session.accessToken && this.isTokenExpired(session.expiresAt)) {
            // Session exists but token is EXPIRED - try to revive it
            console.log('üîÑ Dead session detected (expired token) - attempting automatic revival...');
            console.log('  Expires at:', session.expiresAt ? new Date(parseInt(session.expiresAt)).toISOString() : 'N/A');
            console.log('  Current time:', new Date().toISOString());
            console.log('  Refresh token available:', refreshToken ? 'YES' : 'NO');
            console.log('  Session keys:', session ? Object.keys(session) : []);
            
            if (refreshToken) {
              document.getElementById('app-content').innerHTML = `
                <div class="loading">
                  <div class="spinner"></div>
                  <p>Reviving expired session...</p>
                </div>
              `;
              await this.refreshAccessToken();
            } else {
              console.warn('‚ö†Ô∏è Expired session found but no refresh token available');
              console.warn('‚ö†Ô∏è This session was created before refresh token storage was added');
              console.warn('‚ö†Ô∏è You need to re-authenticate to get a refresh token');
              
              // Show helpful error message
              document.getElementById('app-content').innerHTML = `
                <div class="status-card error">
                  <div class="status-indicator">
                    <div class="status-dot error"></div>
                    <span class="status-text">Session Expired - Re-authentication Required</span>
                  </div>
                  <p style="color: #6b7280; font-size: 14px; margin-top: 8px;">
                    Your session expired and cannot be refreshed automatically because it was created before refresh token storage was implemented.
                  </p>
                  <p style="color: #6b7280; font-size: 14px; margin-top: 8px;">
                    Please click "Connect to SideDrawer" below to re-authenticate. Your new session will include refresh token support.
                  </p>
                </div>
                <button class="btn btn-success" onclick="auth.startOAuthFlow()" style="margin-top: 20px;">Connect to SideDrawer</button>
              `;
            }
          } else if (refreshToken) {
            // No session but have refresh token - try silent refresh
            console.log('üîÑ No session found, but refresh token exists - attempting refresh...');
            document.getElementById('app-content').innerHTML = `
              <div class="loading">
                <div class="spinner"></div>
                <p>Refreshing connection...</p>
              </div>
            `;
            await this.refreshAccessToken();
          } else {
            // No valid session or refresh token
            console.log('‚ö†Ô∏è No session or refresh token found');
            
            // If no OAuth config, show tenant creation flow instead of disconnected status
            if (!OAUTH_CONFIG.clientId) {
              await this.showTenantCreationFlow();
              return false;
            }
            
            this.showDisconnectedStatus();
            return false;
          }
        }

        startPeriodicTokenRefresh() {
          // Clear existing interval
          if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
          }
          
          // Check and refresh token every 5 minutes
          this.refreshInterval = setInterval(async () => {
            console.log('üîÑ Periodic token refresh check...');
            const session = await this.getZohoSession();
            const refreshToken = await this.getRefreshToken();
            if (session && this.isTokenExpired(session.expiresAt)) {
              console.log('üîÑ Token expired, refreshing...');
              await this.refreshAccessToken();
            } else if (!session && refreshToken) {
              console.log('üîÑ No session but refresh token exists, refreshing...');
              await this.refreshAccessToken();
            } else {
              console.log('‚úì Token still valid');
            }
          }, 5 * 60 * 1000); // Every 5 minutes
          
          console.log('‚úÖ Periodic token refresh started (every 5 minutes)');
        }

        async showConnectedStatus() {
          // Start periodic refresh to keep session alive
          this.startPeriodicTokenRefresh();
          
          const session = await this.getZohoSession();
          const expiryDate = session ? new Date(parseInt(session.expiresAt)) : new Date();
          const hasRefreshToken = !!(await this.getRefreshToken());
          
          document.getElementById('app-content').innerHTML = `
            <div class="status-card connected">
              <div class="status-indicator">
                <div class="status-dot connected"></div>
                <span class="status-text">Connected to SideDrawer</span>
              </div>
              <p style="color: #6b7280; font-size: 14px; margin-top: 8px;">Your integration is active and ready to use.</p>
            </div>

            <div style="margin-top:20px;padding:20px;background:#fff;border:1px solid #e5e7eb;border-radius:6px">
              <p style="margin:8px 0;color:#4b5563;font-size:14px"><strong style="color:#111827;font-weight:600">Status:</strong> Authenticated</p>
              <p style="margin:8px 0;color:#4b5563;font-size:14px"><strong style="color:#111827;font-weight:600">Storage:</strong> ${this.zohoInitialized ? 'Zoho Session (shared across widgets)' : 'localStorage (fallback)'}</p>
              <p style="margin:8px 0;color:#4b5563;font-size:14px"><strong style="color:#111827;font-weight:600">Token Expires:</strong> ${expiryDate.toLocaleString()}</p>
              <p style="margin:8px 0;color:#4b5563;font-size:14px"><strong style="color:#111827;font-weight:600">Silent Refresh:</strong> ${hasRefreshToken ? 'Enabled' : 'Disabled'}</p>
            </div>

            <div class="button-group">
              <button class="btn" onclick="auth.disconnect()">Disconnect</button>
              <button class="btn btn-success" onclick="auth.testConnection()">Test Connection</button>
            </div>

            <div id="test-result"></div>
          `;
        }

        showDisconnectedStatus() {
          document.getElementById('app-content').innerHTML = `
            <div class="status-card">
              <div class="status-indicator">
                <div class="status-dot"></div>
                <span class="status-text">Not Connected</span>
              </div>
              <p style="color: #6b7280; font-size: 14px;">Connect your SideDrawer account to enable the integration.</p>
            </div>

            <div class="info-section">
              <p><strong>What is SideDrawer?</strong></p>
              <p>SideDrawer is a secure document storage and sharing platform designed for financial advisors and their clients.</p>
              <br>
              <p><strong>This integration allows you to:</strong></p>
              <ul style="margin-left: 20px; margin-top: 10px; color: #4b5563;">
                <li>Access SideDrawer documents directly from Zoho CRM</li>
                <li>Share content with clients through SideDrawer</li>
                <li>Manage client documents securely</li>
              </ul>
            </div>

            <button class="btn btn-success" onclick="auth.startOAuthFlow()">Connect to SideDrawer</button>
          `;
        }

        showError(message) {
          document.getElementById('app-content').innerHTML = `
            <div class="status-card error">
              <div class="status-indicator">
                <div class="status-dot error"></div>
                <span class="status-text">Connection Error</span>
              </div>
              <div class="error-message">
                ${message}
              </div>
            </div>

            <button class="btn" onclick="auth.checkConnection()">Try Again</button>
          `;
        }

        async checkTenantExists() {
          try {
            const token = await this.getAccessToken();
            if (!token) return false;

            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const tenantApi = isSandbox
              ? 'https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/tenant/shared'
              : 'https://tenants-gateway-api.sidedrawer.com/api/v1/tenants/tenant/shared';

            const response = await fetch(tenantApi, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });

            if (response.ok) {
              const tenants = await response.json();
              return tenants && tenants.length > 0;
            }
            return false;
          } catch (error) {
            console.error('‚ùå Error checking tenant:', error);
            return false;
          }
        }

        async showTenantCreationFlow() {
          // Ensure tenant-wizard container exists
          let wizardContainer = document.getElementById('tenant-wizard');
          if (!wizardContainer) {
            wizardContainer = document.createElement('div');
            wizardContainer.id = 'tenant-wizard';
            wizardContainer.style.display = 'none';
            const container = document.querySelector('.container');
            if (container) {
              container.appendChild(wizardContainer);
            } else {
              document.body.appendChild(wizardContainer);
            }
          }
          
          // Hide main content
          const appContent = document.getElementById('app-content');
          if (appContent) {
            appContent.style.display = 'none';
          }
          
          // Wait for tenantWizard to be available (it's created after SideDrawerAuth)
          let attempts = 0;
          const maxAttempts = 50; // Wait up to 5 seconds (50 * 100ms)
          
          while (attempts < maxAttempts) {
            if (typeof window.tenantWizard !== 'undefined' && window.tenantWizard) {
              try {
                await window.tenantWizard.init();
                return;
              } catch (error) {
                const dict = window.tenantWizard?.state?.dictionary || {};
                this.showError(dict.globalparams_error || 'Failed to initialize tenant creation wizard: ' + error.message);
                return;
              }
            }
            // Wait 100ms before checking again
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          
          // If we get here, tenantWizard never became available
          this.showError('Tenant creation wizard is not available. Please refresh the page.');
        }

        async startOAuthFlow() {
          try {
            // Validate configuration
            if (!OAUTH_CONFIG.clientId) {
              // If no OAuth config, show tenant creation flow directly
              await this.showTenantCreationFlow();
              return;
            }
            
            // Generate PKCE code verifier and challenge
            const codeVerifier = this.generateCodeVerifier();
            const codeChallenge = await this.generateCodeChallenge(codeVerifier);

            // Store code verifier in BOTH localStorage and sessionStorage for redundancy
            localStorage.setItem(STORAGE_KEYS.codeVerifier, codeVerifier);
            sessionStorage.setItem(STORAGE_KEYS.codeVerifier, codeVerifier);
            console.log('‚úì Code verifier stored:', codeVerifier.substring(0, 10) + '...');
            console.log('‚úì Code verifier length:', codeVerifier.length);

            // Build authorization URL with state containing code verifier for fallback
            const stateObj = {
              random: this.generateRandomString(16),
              verifier: codeVerifier
            };
            const state = JSON.stringify(stateObj);
            const encodedState = btoa(state);
            
            console.log('‚úì State object:', { random: stateObj.random, verifier: stateObj.verifier.substring(0, 10) + '...' });
            console.log('‚úì State JSON length:', state.length);
            console.log('‚úì Encoded state length:', encodedState.length);
            
            const authUrl = new URL(OAUTH_CONFIG.authorizationEndpoint);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('client_id', OAUTH_CONFIG.clientId);
            authUrl.searchParams.append('redirect_uri', OAUTH_CONFIG.redirectUri);
            authUrl.searchParams.append('scope', OAUTH_CONFIG.scope);
            authUrl.searchParams.append('audience', OAUTH_CONFIG.audience);
            authUrl.searchParams.append('code_challenge', codeChallenge);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('state', encodedState);

            console.log('Starting OAuth flow...');
            console.log('Authorization URL:', authUrl.toString().substring(0, 100) + '...');
            console.log('Redirect URI:', OAUTH_CONFIG.redirectUri);
            console.log('Client ID:', OAUTH_CONFIG.clientId);

            // Check if we're running inside an iframe (Zoho)
            const isInIframe = window.self !== window.top;
            console.log('Is in iframe:', isInIframe);

            if (isInIframe) {
              console.log('Detected iframe environment - opening popup window');
              
              // Open popup window for OAuth (works in Zoho iframe)
              const width = 600;
              const height = 700;
              const left = (screen.width - width) / 2;
              const top = (screen.height - height) / 2;
              
              const popupUrl = authUrl.toString();
              console.log('üöÄ Opening popup to:', popupUrl.substring(0, 150) + '...');
              console.log('üîë State parameter in URL:', authUrl.searchParams.get('state')?.substring(0, 50) + '...');
              
              const popup = window.open(
                popupUrl,
                'SideDrawer OAuth',
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
              );

              if (!popup) {
                throw new Error('Popup blocked! Please allow popups for this site and try again.');
              }

              // Show waiting status
              document.getElementById('app-content').innerHTML = `
                <div class="status-card">
                  <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span class="status-text">Authenticating...</span>
                  </div>
                  <p style="color: #555; font-size: 14px;">Please complete the login in the popup window.</p>
                  <p style="color: #999; font-size: 12px; margin-top: 10px;">
                    Don't see the popup? Check if your browser blocked it and allow popups for this site.
                  </p>
                </div>
              `;

              // Poll for popup close or callback
              const pollInterval = setInterval(() => {
                if (popup.closed) {
                  clearInterval(pollInterval);
                  console.log('Popup closed - checking for auth completion');
                  // Check if we got redirected back with a code
                  setTimeout(() => this.checkConnection(), 500);
                }
              }, 500);

            } else {
              console.log('Not in iframe - using direct redirect');
              // Not in iframe (localhost testing) - use direct redirect
              window.location.href = authUrl.toString();
            }

          } catch (error) {
            console.error('OAuth flow error:', error);
            this.showError(`Failed to start authentication: ${error.message}`);
          }
        }

        async handleOAuthCallback(code) {
          document.getElementById('app-content').innerHTML = `
            <div class="loading">
              <div class="spinner"></div>
              <p>Completing authentication...</p>
            </div>
          `;

          try {
            const codeVerifier = localStorage.getItem(STORAGE_KEYS.codeVerifier);
            
            if (!codeVerifier) {
              throw new Error('Code verifier not found. Please try again.');
            }

            // Exchange code for token (PKCE - no client_secret)
            const tokenRequestBody = {
              grant_type: 'authorization_code',
              client_id: OAUTH_CONFIG.clientId,
              code: code,
              code_verifier: codeVerifier,
              redirect_uri: OAUTH_CONFIG.redirectUri,
              audience: OAUTH_CONFIG.audience
            };
            
            const tokenResponse = await fetch(OAUTH_CONFIG.tokenEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(tokenRequestBody)
            });

            if (!tokenResponse.ok) {
              const errorData = await tokenResponse.json();
              throw new Error(errorData.error_description || 'Token exchange failed');
            }

            const tokenData = await tokenResponse.json();
            
            // Store tokens
            this.saveTokens(tokenData);
            this.cleanupOAuthState();

            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);

            // Show success
            document.getElementById('app-content').innerHTML = `
              <div class="success-message">
                ‚úì Successfully connected to SideDrawer!
              </div>
            `;

            // Reload to show connected status
            setTimeout(() => this.checkConnection(), 1500);

          } catch (error) {
            console.error('Token exchange error:', error);
            this.showError(`Authentication failed: ${error.message}`);
            this.cleanupOAuthState();
          }
        }

        async refreshAccessToken() {
          const refreshToken = await this.getRefreshToken();
          
          if (!refreshToken) {
            console.error('‚ùå No refresh token available for refresh');
            // Last resort: check session object directly
            const session = await this.getZohoSession();
            if (session && session.refreshToken) {
              console.log('üîÑ Found refresh token in session object, using it...');
              // Use session.refreshToken directly
              const tokenToUse = session.refreshToken;
              // Continue with refresh using this token
              try {
                console.log('üîÑ Refreshing access token...');
                const refreshRequestBody = {
                  grant_type: 'refresh_token',
                  client_id: OAUTH_CONFIG.clientId,
                  refresh_token: tokenToUse,
                  audience: OAUTH_CONFIG.audience
                };
                
                const response = await fetch(OAUTH_CONFIG.tokenEndpoint, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(refreshRequestBody)
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  console.error('‚ùå Token refresh failed:', response.status, errorText);
                  throw new Error(`Token refresh failed: ${response.status}`);
                }

                const tokenData = await response.json();
                console.log('‚úÖ Token refresh successful!');
                this.saveTokens(tokenData);
                this.showConnectedStatus();
                return;
              } catch (error) {
                console.error('‚ùå Token refresh error:', error);
                this.showError(`Failed to refresh session: ${error.message}`);
                return;
              }
            }
            this.showDisconnectedStatus();
            return;
          }

          try {
            console.log('üîÑ Refreshing access token...');
            console.log('  Token endpoint:', OAUTH_CONFIG.tokenEndpoint);
            console.log('  Client ID:', OAUTH_CONFIG.clientId);
            console.log('  Refresh token:', refreshToken.substring(0, 20) + '...');
            
            const refreshRequestBody = {
              grant_type: 'refresh_token',
              client_id: OAUTH_CONFIG.clientId,
              refresh_token: refreshToken,
              audience: OAUTH_CONFIG.audience
            };
            
            const response = await fetch(OAUTH_CONFIG.tokenEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(refreshRequestBody)
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('‚ùå Token refresh failed:', response.status, errorText);
              throw new Error(`Token refresh failed: ${response.status}`);
            }

            const tokenData = await response.json();
            console.log('‚úÖ Token refresh successful!');
            console.log('  New access token length:', tokenData.access_token?.length || 0);
            console.log('  Expires in:', tokenData.expires_in, 'seconds');
            console.log('  New refresh token provided:', !!tokenData.refresh_token);
            
            this.saveTokens(tokenData);
            this.showConnectedStatus();

          } catch (error) {
            console.error('‚ùå Token refresh error:', error);
            console.error('Error details:', error.stack);
            // Don't disconnect immediately - let user try again
            this.showError(`Failed to refresh session: ${error.message}`);
          }
        }

        async testConnection() {
          const resultDiv = document.getElementById('test-result');
          resultDiv.innerHTML = `
            <div class="loading" style="padding: 20px;">
              <div class="spinner"></div>
              <p>Testing connection...</p>
            </div>
          `;

          try {
            const token = await this.getAccessToken();
            
            // Test API call to SideDrawer tenant endpoint
            const response = await fetch('https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/tenant/shared', {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });

            if (response.ok) {
              const data = await response.json();
              
              if (data && data.length > 0) {
                const tenant = data[0];
                const tenantInfo = { 
                  tenantId: tenant.id || "", 
                  brandCode: tenant.defaultBrandCode || "", 
                  region: tenant.region || "" 
                };
                
                resultDiv.innerHTML = `
                  <div class="success-message">
                    ‚úì Connection test successful!
                  </div>
                  <div class="info-section" style="margin-top: 15px;">
                    <strong style="display: block; margin-bottom: 10px;">Tenant Information:</strong>
                    <p><strong>Tenant ID:</strong> ${tenantInfo.tenantId}</p>
                    <p><strong>Brand Code:</strong> ${tenantInfo.brandCode}</p>
                    <p><strong>Region:</strong> ${tenantInfo.region}</p>
                  </div>
                  <div class="token-info" style="margin-top: 15px;">
                    <strong style="display: block; margin-bottom: 5px;">Access Token:</strong>
                    <code style="word-break: break-all; font-size: 11px; display: block; background: #fff; padding: 8px; border-radius: 4px; border: 1px solid #ddd; max-height: 100px; overflow-y: auto;">${token}</code>
                    <button class="btn" style="margin-top: 10px; padding: 8px 16px; font-size: 14px;" onclick="navigator.clipboard.writeText('${token}').then(() => alert('Token copied to clipboard!'))">üìã Copy Token</button>
                  </div>
                `;
              } else {
                throw new Error('No tenant data returned');
              }
            } else {
              const errorText = await response.text().catch(() => '');
              throw new Error(`API returned ${response.status}: ${errorText}`);
            }

          } catch (error) {
            console.error('Connection test error:', error);
            resultDiv.innerHTML = `
              <div class="error-message">
                ‚úó Connection test failed: ${error.message}
              </div>
            `;
          }
        }

        async disconnect() {
          console.log('üîì Disconnecting from SideDrawer...');
          
          // Clear periodic refresh interval
          if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
            console.log('‚úì Periodic refresh stopped');
          }
          
          // Clear Zoho session
          await this.clearZohoSession();
          
          // Clear refresh token from localStorage
          localStorage.removeItem(STORAGE_KEYS.refreshToken);
          
          // Clear all Auth0 cookies (including sidedrawer_refresh_token)
          this.clearAllCookies();
          
          // Clear all localStorage items related to SideDrawer and Auth0
          Object.keys(localStorage).forEach(key => {
            if (key.includes('sidedrawer') || key.includes('auth0') || key.includes('@@') || key.includes('_legacy')) {
              localStorage.removeItem(key);
            }
          });
          
          console.log('‚úì Local session cleared');
          
          // Clear Auth0 session by redirecting to logout endpoint
          // This ensures the user will be prompted to login again
          // Dynamically use the correct Auth0 domain (sandbox or production)
          const auth0Domain = getAuth0Domain();
          const auth0LogoutUrl = `${auth0Domain}/v2/logout?client_id=${OAUTH_CONFIG.clientId}&returnTo=${encodeURIComponent(OAUTH_CONFIG.redirectUri)}`;
          
          console.log('‚úì Redirecting to Auth0 logout:', auth0Domain);
          
          // Redirect to Auth0 logout, which will then redirect back to our app
          window.location.href = auth0LogoutUrl;
        }
        
        clearAllCookies() {
          // Get all cookies
          const cookies = document.cookie.split(';');
          
          // Clear each cookie by setting expiry to past date
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i];
            const eqPos = cookie.indexOf('=');
            const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
            
            // Clear for current path and domain
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=' + window.location.hostname;
            
            // Try to clear for parent domain (e.g., .sidedrawer.com)
            const domainParts = window.location.hostname.split('.');
            if (domainParts.length > 1) {
              const parentDomain = '.' + domainParts.slice(-2).join('.');
              document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=' + parentDomain;
            }
            
            console.log('üóëÔ∏è Cleared cookie:', name);
          }
        }

        async saveTokens(tokenData) {
          // Store access token in Zoho session (shared across widgets)
          const expiresAt = Date.now() + (tokenData.expires_in * 1000);
          
          // DEBUG: Log what we received from OAuth
          console.log('üíæ Saving tokens - OAuth response contains:');
          console.log('  - access_token:', !!tokenData.access_token, tokenData.access_token ? `(${tokenData.access_token.length} chars)` : 'MISSING');
          console.log('  - refresh_token:', !!tokenData.refresh_token, tokenData.refresh_token ? `(${tokenData.refresh_token.length} chars)` : 'MISSING');
          console.log('  - expires_in:', tokenData.expires_in);
          console.log('  - token_type:', tokenData.token_type);
          console.log('  - All keys in tokenData:', Object.keys(tokenData));
          
          // Get existing refresh token (in case new one not provided)
          // Check both session object and localStorage
          const session = await this.getZohoSession();
          const existingRefreshToken = session?.refreshToken || localStorage.getItem(STORAGE_KEYS.refreshToken);
          
          console.log('üíæ Existing refresh token check:');
          console.log('  - In session object:', !!session?.refreshToken);
          console.log('  - In localStorage:', !!localStorage.getItem(STORAGE_KEYS.refreshToken));
          
          // Use new refresh token if provided, otherwise keep existing one
          const refreshTokenToUse = tokenData.refresh_token || existingRefreshToken;
          
          const sessionData = {
            accessToken: tokenData.access_token,
            expiresAt: expiresAt,
            tokenType: tokenData.token_type || 'Bearer',
            // Store refresh token in session object too (for consistency with @SidedrawerRelated)
            refreshToken: refreshTokenToUse || null
          };
          
          console.log('üíæ Saving session data...');
          console.log('  Access token length:', tokenData.access_token?.length || 0);
          console.log('  Expires at:', new Date(expiresAt).toISOString());
          console.log('  Refresh token in session:', !!sessionData.refreshToken);
          if (sessionData.refreshToken) {
            console.log('  Refresh token preview:', sessionData.refreshToken.substring(0, 20) + '...');
          }
          
          await this.setZohoSession(sessionData);
          
          // Store refresh token in localStorage (persistent) - ALWAYS save if we have one
          if (refreshTokenToUse) {
            localStorage.setItem(STORAGE_KEYS.refreshToken, refreshTokenToUse);
            console.log('‚úÖ Refresh token stored in localStorage:', STORAGE_KEYS.refreshToken);
            console.log('‚úÖ Refresh token also stored in session object');
          } else {
            console.error('‚ùå CRITICAL: No refresh token available to store!');
            console.error('  - OAuth response had refresh_token:', !!tokenData.refresh_token);
            console.error('  - Existing refresh token found:', !!existingRefreshToken);
            console.error('  - This means session cannot be refreshed automatically!');
            console.error('  - User will need to re-authenticate when token expires.');
          }
        }

        async getAccessToken() {
          const session = await this.getZohoSession();
          return session ? session.accessToken : null;
        }

        async getRefreshToken() {
          // PRIORITY 1: Check session object (new format - refresh token stored in session)
          const session = await this.getZohoSession();
          console.log('[getRefreshToken] Checking session object:', {
            hasSession: !!session,
            hasRefreshToken: !!(session?.refreshToken),
            sessionKeys: session ? Object.keys(session) : []
          });
          
          if (session && session.refreshToken) {
            console.log('‚úÖ Refresh token found in session object');
            return session.refreshToken;
          }
          
          // PRIORITY 2: Check legacy localStorage location (for backward compatibility)
          const legacyToken = localStorage.getItem(STORAGE_KEYS.refreshToken);
          console.log('[getRefreshToken] Checking legacy localStorage:', {
            key: STORAGE_KEYS.refreshToken,
            found: !!legacyToken
          });
          
          if (legacyToken) {
            console.log('‚úÖ Refresh token found in legacy localStorage');
            return legacyToken;
          }
          
          // PRIORITY 3: Check all localStorage keys containing "refresh" or "token"
          console.log('[getRefreshToken] Scanning localStorage for refresh tokens...');
          const allKeys = Object.keys(localStorage);
          const tokenKeys = allKeys.filter(k => k.toLowerCase().includes('refresh') || k.toLowerCase().includes('token'));
          console.log('[getRefreshToken] Found potential token keys:', tokenKeys);
          tokenKeys.forEach(key => {
            const value = localStorage.getItem(key);
            console.log(`  - ${key}: ${value ? value.substring(0, 20) + '...' : 'empty'}`);
          });
          
          console.log('‚ö†Ô∏è No refresh token found in session object or localStorage');
          return null;
        }

        isTokenExpired(expiresAt) {
          if (!expiresAt) return true;
          // Add 5 minute buffer before expiry
          const bufferTime = 5 * 60 * 1000;
          return Date.now() >= (parseInt(expiresAt) - bufferTime);
        }

        cleanupOAuthState() {
          localStorage.removeItem(STORAGE_KEYS.codeVerifier);
        }

        // PKCE Helper Functions
        generateCodeVerifier() {
          const array = new Uint8Array(32);
          crypto.getRandomValues(array);
          return this.base64UrlEncode(array);
        }

        async generateCodeChallenge(codeVerifier) {
          const encoder = new TextEncoder();
          const data = encoder.encode(codeVerifier);
          const hash = await crypto.subtle.digest('SHA-256', data);
          return this.base64UrlEncode(new Uint8Array(hash));
        }

        base64UrlEncode(array) {
          return btoa(String.fromCharCode.apply(null, array))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
        }

        generateRandomString(length) {
          const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          let result = '';
          for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          return result;
        }
      }

      // Stripe Service for PCI-compliant payment processing
      class StripeService {
        constructor() {
          this.stripe = null;
          this.elements = null;
          this.cardElement = null;
          this.stripePublicKey = null; // Will be set from config or environment
        }

        async initialize(stripePublicKey) {
          if (!stripePublicKey) {
            console.warn('‚ö†Ô∏è Stripe public key not provided. Stripe Elements will not work.');
            return false;
          }

          try {
            if (typeof Stripe === 'undefined') {
              console.error('‚ùå Stripe.js not loaded. Make sure https://js.stripe.com/v3/ is included.');
              return false;
            }

            this.stripePublicKey = stripePublicKey;
            this.stripe = Stripe(stripePublicKey);
            
            this.elements = this.stripe.elements({
              appearance: {
                theme: 'stripe',
                variables: {
                  colorPrimary: '#ff6b35',
                  colorBackground: '#ffffff',
                  colorText: '#30313d',
                  colorDanger: '#df1b41',
                  fontFamily: 'system-ui, sans-serif',
                  spacingUnit: '4px',
                  borderRadius: '4px',
                },
              },
            });

            console.log('‚úÖ Stripe initialized successfully');
            return true;
          } catch (error) {
            console.error('‚ùå Error initializing Stripe:', error);
            return false;
          }
        }

        async createCardElement(containerId) {
          if (!this.elements) {
            console.error('‚ùå Stripe Elements not initialized. Call initialize() first.');
            return null;
          }

          try {
            const container = document.getElementById(containerId);
            if (!container) {
              console.error(`‚ùå Container element not found: #${containerId}`);
              return null;
            }

            this.cardElement = this.elements.create('card', {
              style: {
                base: {
                  fontSize: '16px',
                  color: '#30313d',
                  '::placeholder': {
                    color: '#aab7c4',
                  },
                },
                invalid: {
                  color: '#df1b41',
                  iconColor: '#df1b41',
                },
              },
            });

            this.cardElement.mount(`#${containerId}`);
            
            // Listen for errors
            this.cardElement.on('change', (event) => {
              const errorElement = document.getElementById(`${containerId}-error`);
              if (errorElement) {
                if (event.error) {
                  errorElement.textContent = event.error.message;
                  errorElement.style.display = 'block';
                } else {
                  errorElement.textContent = '';
                  errorElement.style.display = 'none';
                }
              }
            });

            console.log('‚úÖ Stripe card element created and mounted');
            return this.cardElement;
          } catch (error) {
            console.error('‚ùå Error creating card element:', error);
            return null;
          }
        }

        async createPaymentMethod(billingDetails) {
          if (!this.stripe || !this.cardElement) {
            return { paymentMethodId: null, error: { message: 'Stripe not initialized or card element not created' } };
          }

          try {
            const { paymentMethod, error } = await this.stripe.createPaymentMethod({
              type: 'card',
              card: this.cardElement,
              billing_details: billingDetails,
            });

            if (error) {
              return { paymentMethodId: null, error };
            }

            if (!paymentMethod) {
              return { paymentMethodId: null, error: { message: 'Failed to create payment method' } };
            }

            console.log('‚úÖ Payment method created:', paymentMethod.id);
            return { paymentMethodId: paymentMethod.id };
          } catch (error) {
            console.error('‚ùå Error creating payment method:', error);
            return { paymentMethodId: null, error };
          }
        }

        unmountCardElement() {
          if (this.cardElement) {
            this.cardElement.unmount();
            this.cardElement = null;
            console.log('‚úÖ Stripe card element unmounted');
          }
        }

        destroy() {
          this.unmountCardElement();
          this.elements = null;
          this.stripe = null;
          this.stripePublicKey = null;
        }
      }

      // Initialize Stripe service (will be initialized when needed with public key)
      const stripeService = new StripeService();

      // Tenant Creation Wizard - Complete Frontend Implementation
      class TenantCreationWizard {
        constructor() {
          this.state = {
            currentStep: 0,
            // Step 1: Tenant Info
            email: '',
            password: '',
            confirmPassword: '',
            tenantName: '',
            tenantDomain: '',
            region: '',
            // Step 2: Subscription
            selectedPrice: null,
            currency: null,
            priceTab: 'month', // 'month' or 'year'
            prices: [],
            monthlyPrices: [],
            yearlyPrices: [],
            usersPrices: [], // Prices with product.audience === 'users'
            monthlyUsersPrices: [],
            yearlyUsersPrices: [],
            totalAdminUsers: 0,
            dictionary: null,
            dictionaryPrices: [],
            databaseRegions: [],
            currencies: [],
            // Step 3: Payment
            cardElement: null,
            billingAddress: null,
            cardholderName: '',
            selectedPaymentMethod: null,
            paymentMethods: [],
            paymentMethodToken: null, // Stores Stripe payment method token created on step 2
            stripePublicKey: null,
            // UI State
            loading: false,
            error: null,
            validationError: null
          };
        }

        async init() {
          try {
            // Fetch dictionary FIRST (needed for currencies)
            await this.loadDictionary();
            
            // Load prices
            await this.loadPrices();
            
            // Load regions from dictionary
            await this.loadRegions();
            
            // Load currencies from dictionary and set default
            await this.loadCurrencies();
            
            // Get Stripe public key from backend/config API
            await this.loadStripePublicKey();
            
            // Render wizard
            this.render();
          } catch (error) {
            throw error;
          }
        }

        async loadDictionary() {
          try {
            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const apiUrl = isSandbox
              ? 'https://api-sbx.sidedrawersbx.com/api/v1/configs/content/dictionaries/console_20210501/locale/en-CA'
              : 'https://api.sidedrawer.com/api/v1/configs/content/dictionaries/console_20210501/locale/en-CA';

            const response = await fetch(apiUrl);
            if (response.ok) {
              const data = await response.json();
              this.state.dictionary = data;
              this.state.databaseRegions = data.collections?.databaseregions || [];
              // Filter currencies - match Angular's dicCurrenciesSelector (filter by enabled)
              const rawCurrencies = data.collections?.currencies || [];
              this.state.currencies = Array.isArray(rawCurrencies) 
                ? rawCurrencies.filter(c => c && c.enabled === true && c.currency) 
                : [];
            }
          } catch (error) {
            throw error;
          }
        }

        async loadPrices() {
          try {
            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const apiUrl = isSandbox
              ? 'https://api-sbx.sidedrawersbx.com/api/v1/subscriptions/prices'
              : 'https://api.sidedrawer.com/api/v1/subscriptions/prices';

            const token = await auth.getAccessToken();
            const headers = {
              'Content-Type': 'application/json'
            };
            if (token) {
              headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(apiUrl, { headers });
            if (response.ok) {
              const prices = await response.json();
              this.state.prices = Array.isArray(prices) ? prices.filter(p => p.active === true) : [];
              // Store dictionary prices if available
              if (this.state.dictionary?.collections?.prices) {
                this.state.dictionaryPrices = this.state.dictionary.collections.prices;
              }
              // Update price lists if currency is already set
              if (this.state.currency) {
                this.updatePriceLists();
              }
            }
          } catch (error) {
            throw error;
          }
        }

        async loadRegions() {
          // Regions loaded from dictionary
          if (this.state.databaseRegions.length > 0) {
            // Set default region if available
            if (!this.state.region && this.state.databaseRegions.length > 0) {
              this.state.region = this.state.databaseRegions[0].countrycode;
            }
          }
        }

        async loadCurrencies() {
          // Currencies loaded from dictionary - match Angular's behavior
          // Set default currency from first enabled currency (matching subscriptions.effects.ts)
          if (this.state.currencies.length > 0 && !this.state.currency) {
            const validCurrencies = this.state.currencies.filter(c => c && c.currency && c.enabled);
            
            if (validCurrencies.length > 0) {
              // Set default currency (USD or first available) - matching Angular's SubscriptionsCurrencyChange
              const usdCurrency = validCurrencies.find(c => c.currency && c.currency.toLowerCase() === 'usd');
              this.state.currency = usdCurrency 
                ? usdCurrency.currency.toLowerCase() 
                : validCurrencies[0].currency.toLowerCase();
              
              // Update price lists after setting currency
              if (this.state.prices.length > 0) {
                this.updatePriceLists();
              }
            }
          }
        }

        async loadStripePublicKey() {
          try {
            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const apiBase = isSandbox
              ? 'https://api-sbx.sidedrawersbx.com/api/v1'
              : 'https://api.sidedrawer.com/api/v1';
            
            // Try to get Stripe public key from subscriptions API
            try {
              const response = await fetch(`${apiBase}/subscriptions/subscriptions/public-key`);
              if (response.ok) {
                const data = await response.json();
                this.state.stripePublicKey = data.publicKey || data.stripePublicKey || data.key || null;
              } else {
                // Use default fallback if API is not configured
                this.state.stripePublicKey = 'pk_test_DJsfKIOeJStMWElaD8bLc17E';
              }
            } catch (e) {
              // Use default fallback if API call fails
              this.state.stripePublicKey = 'pk_test_DJsfKIOeJStMWElaD8bLc17E';
            }
          } catch (error) {
            // Use default fallback on any error
            this.state.stripePublicKey = 'pk_test_DJsfKIOeJStMWElaD8bLc17E';
          }
        }

        updatePriceLists() {
          const currency = this.state.currency;
          if (!currency) {
            this.state.monthlyPrices = [];
            this.state.yearlyPrices = [];
            this.state.monthlyUsersPrices = [];
            this.state.yearlyUsersPrices = [];
            return;
          }

          // Filter by product.audience === 'pros' (matching Angular's pricesListProSelector)
          const prosPrices = this.state.prices.filter(p => {
            if (!p.active) return false;
            if (!p.metadata) return false;
            
            // Exact match as Angular: p.metadata['product.audience'] === 'pros'
            return p.metadata['product.audience'] === 'pros';
          });

          // Filter by product.audience === 'users' (matching Angular's pricesListUsersSelector)
          const usersPrices = this.state.prices.filter(p => {
            if (!p.active) return false;
            if (!p.metadata) return false;
            
            return p.metadata['product.audience'] === 'users';
          });
          this.state.usersPrices = usersPrices;

          // Monthly prices: filter pros prices by interval 'month' (matching pricesListProByIntervalSelector)
          // Angular filters by currency in template using isHidden(), but we filter here for efficiency
          this.state.monthlyPrices = prosPrices.filter(
            p => p.interval === 'month' && 
                 p.currency && p.currency.toLowerCase() === currency.toLowerCase()
          );

          // Yearly prices: filter pros prices by interval 'year' (matching pricesListProByIntervalSelector)
          const yearlyProsPrices = prosPrices.filter(
            p => p.interval === 'year' && 
                 p.currency && p.currency.toLowerCase() === currency.toLowerCase()
          );

          // Monthly users prices: filter users prices by interval 'month' and currency
          this.state.monthlyUsersPrices = usersPrices.filter(
            p => p.interval === 'month' && 
                 p.currency && p.currency.toLowerCase() === currency.toLowerCase()
          );

          // Yearly users prices: filter users prices by interval 'year' and currency
          this.state.yearlyUsersPrices = usersPrices.filter(
            p => p.interval === 'year' && 
                 p.currency && p.currency.toLowerCase() === currency.toLowerCase()
          );

          // Fallback: If no pros yearly prices, show retail yearly prices
          // This handles cases where yearly prices use 'retail' audience
          if (yearlyProsPrices.length === 0) {
            const retailPrices = this.state.prices.filter(p => {
              if (!p.active) return false;
              if (!p.metadata) return false;
              return p.metadata['product.audience'] === 'retail';
            });
            
            this.state.yearlyPrices = retailPrices.filter(
              p => p.interval === 'year' && 
                   p.currency && p.currency.toLowerCase() === currency.toLowerCase()
            );
          } else {
            this.state.yearlyPrices = yearlyProsPrices;
          }
        }

        render() {
          let wizardContainer = document.getElementById('tenant-wizard');
          if (!wizardContainer) {
            console.error('‚ùå tenant-wizard container not found, creating it...');
            // Create the container if it doesn't exist
            wizardContainer = document.createElement('div');
            wizardContainer.id = 'tenant-wizard';
            wizardContainer.style.display = 'none';
            const container = document.querySelector('.container');
            if (container) {
              container.appendChild(wizardContainer);
            } else {
              document.body.appendChild(wizardContainer);
            }
            console.log('‚úÖ Created tenant-wizard container');
          }

          // Hide main content, show wizard
          const appContent = document.getElementById('app-content');
          if (appContent) {
            appContent.style.display = 'none';
          }
          wizardContainer.style.display = 'block';

          wizardContainer.innerHTML = `
            <div class="tenant-wizard">
              <div class="wizard-header">
                <h1>${this.getDictionaryValue('tenantsetup_formtitle') || 'Create Your Business Account'}</h1>
                <p>${this.getDictionaryValue('tenantsetup_formdescription') || 'Set up your SideDrawer account in a few simple steps'}</p>
              </div>

              <div class="wizard-stepper">
                <div class="wizard-step ${this.state.currentStep === 0 ? 'active' : this.state.currentStep > 0 ? 'completed' : ''}">
                  <div class="wizard-step-circle">${this.state.currentStep > 0 ? '‚úì' : '1'}</div>
                  <div class="wizard-step-label">${this.getDictionaryValue('tenantsetupname_steptitle') || 'Business Info'}</div>
                </div>
                <div class="wizard-step ${this.state.currentStep === 1 ? 'active' : this.state.currentStep > 1 ? 'completed' : ''}">
                  <div class="wizard-step-circle">${this.state.currentStep > 1 ? '‚úì' : '2'}</div>
                  <div class="wizard-step-label">${this.getDictionaryValue('tenantsetupsubscription_steptitle') || 'Subscription'}</div>
                </div>
                <div class="wizard-step ${this.state.currentStep === 2 ? 'active' : this.state.currentStep > 2 ? 'completed' : ''}">
                  <div class="wizard-step-circle">${this.state.currentStep > 2 ? '‚úì' : '3'}</div>
                  <div class="wizard-step-label">${this.getDictionaryValue('tenantsetuppayment_steptitle') || 'Payment'}</div>
                </div>
              </div>

              <div class="wizard-content">
                ${this.renderStep()}
              </div>

              <div class="wizard-footer">
                ${this.state.currentStep > 0 ? `<button class="btn" onclick="tenantWizard.previousStep()">${this.getDictionaryValue('globalparams_back') || 'Back'}</button>` : '<div></div>'}
                <button class="btn btn-success" onclick="if(window.tenantWizard){window.tenantWizard.nextStep();}else{console.error('tenantWizard not found');}" ${this.state.loading ? 'disabled' : ''} id="wizard-next-button">
                  ${this.state.currentStep === 3 
                    ? (this.getDictionaryValue('tenantsetuppayment_primarybutton') || 'Create Account')
                    : (this.getDictionaryValue('globalparams_next') || 'Next')}
                </button>
              </div>
            </div>
          `;

          // Attach event listeners
          this.attachListeners();
        }

        renderStep() {
          if (this.state.currentStep === 0) {
            return this.renderStep1();
          } else if (this.state.currentStep === 1) {
            return this.renderStep2();
          } else if (this.state.currentStep === 2) {
            return this.renderStep3();
          } else if (this.state.currentStep === 3) {
            return this.renderStep4();
          }
          return '';
        }

        renderStep1() {
          const dict = this.state.dictionary || {};
          return `
            ${this.state.validationError ? `<div class="validation-error">${this.state.validationError}</div>` : ''}
            
            <div class="wizard-form-group">
              <label class="wizard-form-label">${dict.signup_email || 'Email Address'}</label>
              <input 
                type="email" 
                class="wizard-form-input" 
                id="email-input"
                placeholder="${dict.signup_emailplaceholder || 'your.email@example.com'}"
                value="${this.state.email || ''}"
              />
              <div class="wizard-form-error" id="email-error"></div>
            </div>

            <div class="wizard-form-group">
              <label class="wizard-form-label">${dict.signup_password || 'Password'}</label>
              <input 
                type="password" 
                class="wizard-form-input" 
                id="password-input"
                placeholder="${dict.signup_passwordplaceholder || 'Enter a secure password'}"
                value="${this.state.password || ''}"
              />
              <div class="wizard-form-error" id="password-error"></div>
            </div>

            <div class="wizard-form-group">
              <label class="wizard-form-label">${dict.signup_confirmpassword || 'Confirm Password'}</label>
              <input 
                type="password" 
                class="wizard-form-input" 
                id="confirm-password-input"
                placeholder="${dict.signup_confirmpasswordplaceholder || 'Confirm your password'}"
                value="${this.state.confirmPassword || ''}"
              />
              <div class="wizard-form-error" id="confirm-password-error"></div>
            </div>

            <div class="wizard-form-group">
              <label class="wizard-form-label">${dict.tenantsetupname_tenantname || 'Business Name'}</label>
              <input 
                type="text" 
                class="wizard-form-input" 
                id="tenant-name-input"
                placeholder="${dict.tenantsetupname_tenantnameplaceholder || 'Enter your business name'}"
                value="${this.state.tenantName || ''}"
              />
              <div class="wizard-form-error" id="tenant-name-error"></div>
            </div>

            <div class="wizard-form-group">
              <label class="wizard-form-label">${dict.tenantsetupname_tenantsubdomain || 'Domain'}</label>
              <div style="display: flex; align-items: center; gap: 8px;">
                <input 
                  type="text" 
                  class="wizard-form-input" 
                  id="tenant-domain-input"
                  placeholder="${dict.tenantsetupname_tenantsubdomainplaceholder || 'your-domain'}"
                  value="${this.state.tenantDomain || ''}"
                  style="flex: 1;"
                />
                <span style="color: #6b7280;">.sidedrawer.com</span>
              </div>
              <div class="wizard-form-error" id="tenant-domain-error"></div>
            </div>

            <div class="wizard-form-group">
              <label class="wizard-form-label">${dict.tenantsetupname_tenantregion || 'Region'}</label>
              <select class="wizard-form-select" id="region-select">
                <option value="">${dict.tenantsetupname_tenantregionplaceholder || 'Select region'}</option>
                ${this.state.databaseRegions.map(region => `
                  <option value="${region.countrycode}" ${this.state.region === region.countrycode ? 'selected' : ''}>
                    ${this.getCountryName(region.countrycode)}
                  </option>
                `).join('')}
              </select>
              <div class="wizard-form-error" id="region-error"></div>
            </div>
          `;
        }

        renderStep2() {
          const dict = this.state.dictionary || {};
          // Ensure price lists are updated before rendering
          this.updatePriceLists();
          const usersPricesToShow = this.state.priceTab === 'month' ? this.state.monthlyUsersPrices : this.state.yearlyUsersPrices;
          const availableCurrencies = this.state.currencies.filter(c => c && c.currency && c.enabled);
          
          return `
            ${this.state.validationError ? `<div class="validation-error">${this.state.validationError}</div>` : ''}
            
            <p style="margin-bottom: 24px; color: #374151;">${dict.tenantsignupsubscription_description || dict.tenantsetupsubscription_description || 'Select your subscription plan'}</p>
            
            <div class="tenant-creation-form-price-section">
              <div class="tenant-creation-form-price-section-currency">
                <h4>${dict.tenantsignupsubscription_selectcurrency || dict.tenantsetupsubscription_selectcurrency || 'Currency'}</h4>
                <div class="toggle-button-group">
                  ${availableCurrencies.map(currency => `
                    <button
                      class="toggle-button ${this.state.currency && this.state.currency.toLowerCase() === currency.currency.toLowerCase() ? 'active' : ''}"
                      onclick="tenantWizard.selectCurrency('${currency.currency}')"
                    >
                      ${currency.symbol} ${currency.isoLabel}
                    </button>
                  `).join('')}
                </div>
              </div>

              <div class="tenant-creation-form-price-section-currency">
                <h4>${dict.tenantsignupsubscription_selectfrequency || dict.tenantsetupsubscription_selectfrequency || 'Frequency'}</h4>
                <div class="toggle-button-group">
                  <button
                    class="toggle-button ${this.state.priceTab === 'month' ? 'active' : ''}"
                    onclick="tenantWizard.setPriceTab('month')"
                  >
                    ${dict.tenantsignupsubscription_monthlytab || dict.subscription_monthly || 'Monthly'}
                  </button>
                  <button
                    class="toggle-button ${this.state.priceTab === 'year' ? 'active' : ''}"
                    onclick="tenantWizard.setPriceTab('year')"
                  >
                    ${dict.tenantsignupsubscription_yearlytab || dict.subscription_yearly || 'Yearly'}
                  </button>
                </div>
              </div>

              <form class="tenant-creation-form-price-section-users" onsubmit="return false;">
                <h4>${dict.tenantsignupsubscription_selectusers || 'Total Admin Users'}</h4>
                <input
                  type="number"
                  id="total-admin-users-input"
                  class="wizard-form-input"
                  placeholder="${dict.tenantsignupsubscription_userslabel || 'Number of users'}"
                  value="${this.state.totalAdminUsers || ''}"
                  min="0"
                  style="width: 100%;"
                />
                <div class="wizard-form-error" id="users-error"></div>
              </form>

              <div class="tenant-creation-form-price-section-price">
                <h4>${dict.tenantsignupsubscription_selectprice || 'Plan preference'}</h4>
                <div class="tenant-creation-form-price-section-price-list">
                  ${usersPricesToShow.length > 0 ? usersPricesToShow.map(price => {
                    const dictPrice = this.getDictionaryPrice(price.id);
                    if (!dictPrice) return '';
                    
                    const isSelected = this.state.selectedPrice?.id === price.id;
                    const currencyObj = this.state.currencies.find(c => c && c.currency && c.currency.toLowerCase() === price.currency?.toLowerCase());
                    const currencySymbol = currencyObj?.symbol || (price.currency === 'usd' ? '$' : price.currency === 'cad' ? 'C$' : '');
                    const amount = price.tiers && price.tiers.length > 0 ? price.tiers[0].flat_amount : price.amount;
                    const formattedAmount = (amount / 100).toFixed(2);
                    const listPrice = dictPrice.listPricePerUnit ? (dictPrice.listPricePerUnit / 100).toFixed(2) : null;
                    
                    return `
                      <div 
                        class="app-tenant-creation-form-price-card ${isSelected ? 'selected' : ''}"
                        onclick="tenantWizard.selectPrice('${price.id}')"
                      >
                        <div class="selectable-price-card ${isSelected ? 'active' : ''}">
                          <div class="selectable-price-card-content">
                            <div class="selectable-price-card-name">${dictPrice.name}</div>
                            <div class="selectable-price-card-price">
                              ${listPrice ? `<span style="text-decoration: line-through; color: #9ca3af; margin-right: 8px;">${currencySymbol}${listPrice}</span>` : ''}
                              <span>${currencySymbol}${formattedAmount}</span>
                              <span class="selectable-price-card-currency">${currencyObj?.isoLabel || price.currency?.toUpperCase() || ''}</span>
                              <span class="selectable-price-card-unit">/${price.interval === 'month' ? 'user/month' : 'user/year'}</span>
                            </div>
                          </div>
                          ${isSelected ? '<div class="selectable-price-card-checkmark">‚úì</div>' : ''}
                        </div>
                      </div>
                    `;
                  }).filter(html => html !== '').join('') : ''}
                </div>
              </div>
            </div>
          `;
        }

        renderStep3() {
          const dict = this.state.dictionary || {};
          
          return `
            ${this.state.validationError ? `<div class="validation-error">${this.state.validationError}</div>` : ''}
            
            ${this.state.paymentMethods.length > 0 ? `
              <div style="margin-bottom: 24px;">
                <label class="wizard-form-label">${dict.paymentdetails_selectpaymentmethod || 'Select Payment Method'}</label>
                ${this.state.paymentMethods.map(pm => `
                  <div 
                    class="price-card ${this.state.selectedPaymentMethod?.id === pm.id ? 'selected' : ''}"
                    onclick="tenantWizard.selectPaymentMethod('${pm.id}')"
                    style="margin-bottom: 12px;"
                  >
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                      <div>
                        <strong>${pm.card?.brand || (dict.paymentdetails_card || 'Card')} ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ${pm.card?.last4 || ''}</strong>
                        <div style="color: #6b7280; font-size: 14px;">${dict.paymentdetails_expires || 'Expires'} ${pm.card?.expMonth}/${pm.card?.expYear}</div>
                      </div>
                      ${this.state.selectedPaymentMethod?.id === pm.id ? '<span>‚úì</span>' : ''}
                    </div>
                  </div>
                `).join('')}
              </div>
            ` : ''}

            <div style="margin-bottom: 24px;">
              <label class="wizard-form-label">${dict.paymentdetails_addnewcard || 'Add New Payment Method'}</label>
              
              ${this.state.stripePublicKey ? `
                <div class="stripe-card-element-container">
                  <div id="card-element"></div>
                  <div id="card-element-error" class="stripe-error"></div>
                </div>
              ` : `
                <div class="validation-error">
                  ${dict.paymentdetails_stripenotconfigured || 'Stripe is not configured. Please contact support.'}
                </div>
              `}

              <div class="wizard-form-group" style="margin-top: 16px;">
                <label class="wizard-form-label">${dict.paymentdetails_addnewcardname || 'Cardholder Name'}</label>
                <input 
                  type="text" 
                  class="wizard-form-input" 
                  id="cardholder-name-input"
                  placeholder="${dict.paymentdetails_addnewcardnameplaceholder || 'John Doe'}"
                  value="${this.state.cardholderName || ''}"
                />
              </div>

              <div class="billing-address-section">
                <label class="wizard-form-label">${dict.paymentdetails_addnewcardbillingaddress || 'Billing Address'}</label>
                <button class="btn" onclick="tenantWizard.showBillingAddressDialog()" style="width: 100%;">
                  ${this.state.billingAddress 
                    ? (dict.paymentdetails_updatebillingaddress || 'Update Billing Address')
                    : (dict.paymentdetails_addbillingaddress || 'Add Billing Address')}
                </button>
                ${this.state.billingAddress ? `
                  <div style="margin-top: 12px; padding: 12px; background: white; border-radius: 4px; color: #374151;">
                    ${this.state.billingAddress.line1}<br>
                    ${this.state.billingAddress.city}, ${this.state.billingAddress.state} ${this.state.billingAddress.postalCode}<br>
                    ${this.state.billingAddress.country}
                  </div>
                ` : ''}
              </div>
            </div>
          `;
        }

        renderStep4() {
          const dict = this.state.dictionary || {};
          
          // Debug logging
          if (!this.state.selectedPrice) {
            console.warn('‚ö†Ô∏è renderStep4: selectedPrice is null', this.state);
            return `<div class="validation-error">No subscription plan selected. Please go back and select a plan.</div>`;
          }
          
          const dictPrice = this.getDictionaryPrice(this.state.selectedPrice.id);
          if (!dictPrice) {
            console.warn('‚ö†Ô∏è renderStep4: dictPrice not found for price', this.state.selectedPrice.id, 'Available prices:', this.state.dictionary?.collections?.prices?.map(p => p.stripePriceId));
            // Fallback: use price data directly if dictionary price not found
            const currencyObj = this.state.currencies.find(c => c && c.currency && c.currency.toLowerCase() === this.state.selectedPrice.currency?.toLowerCase());
            const currencySymbol = currencyObj?.symbol || (this.state.selectedPrice.currency === 'usd' ? '$' : this.state.selectedPrice.currency === 'cad' ? 'C$' : '');
            const currencyLabel = currencyObj?.isoLabel || this.state.selectedPrice.currency?.toUpperCase() || '';
            const amount = this.state.selectedPrice.tiers && this.state.selectedPrice.tiers.length > 0 
              ? this.state.selectedPrice.tiers[0].flat_amount 
              : this.state.selectedPrice.amount;
            const pricePerUnit = amount / 100;
            const users = this.state.totalAdminUsers || 0;
            const isYearly = this.state.selectedPrice.interval === 'year';
            const total = isYearly ? pricePerUnit * users * 12 : pricePerUnit * users;
            
            return `
              <div class="tenant-creation-form-price-selected-resume">
                <div class="tenant-creation-form-price-selected-resume-title">
                  <h2>${this.state.selectedPrice.id}</h2>
                </div>
                <p class="tenant-creation-form-price-selected-price">
                  <span>${currencySymbol}${pricePerUnit.toFixed(2)}</span>
                  <span class="tenant-creation-form-price-selected-price">${currencyLabel}</span>
                  <span class="tenant-creation-form-price-selected-description">/${isYearly ? 'user/year' : 'user/month'}</span>
                </p>
                <hr style="margin: 24px 0; border: none; border-top: 1px solid #e5e7eb;" />
                <h3 class="tenant-creation-form-price-selected-resume-section-title">
                  ${dict.tenantsignupsummary_tabletitle?.replace('[[frequency]]', isYearly ? (dict.tenantsignupsubscription_yearlytab || 'yearly').toLowerCase() : (dict.tenantsignupsubscription_monthlytab || 'monthly').toLowerCase()) || 'Recurring ' + (isYearly ? 'yearly' : 'monthly') + ' cost'}
                </h3>
                <div class="tenant-creation-form-price-selected-resume-section-line">
                  <span class="tenant-creation-form-price-selected-resume-section-line-title">Subscription</span>
                  <span class="tenant-creation-form-price-selected-resume-section-line-amount">
                    ${currencySymbol}${total.toFixed(2)} ${currencyLabel}
                  </span>
                  <p class="tenant-creation-form-price-selected-resume-section-line-description">
                    ${currencySymbol}${pricePerUnit.toFixed(2)} ${currencyLabel} x ${users} users${isYearly ? ' x 12' : ''}
                  </p>
                </div>
                <hr style="margin: 24px 0; border: none; border-top: 1px solid #e5e7eb;" />
                <div class="tenant-creation-form-price-selected-total-section-line">
                  <span class="tenant-creation-form-price-selected-total-section-line-title">
                    ${dict.tenantsignupsummary_tabletotallabel || "Today's total"}
                  </span>
                  <span class="tenant-creation-form-price-selected-total-section-line-amount">
                    ${currencySymbol}${total.toFixed(2)} ${currencyLabel}
                  </span>
                </div>
              </div>
            `;
          }
          
          const currencyObj = this.state.currencies.find(c => c && c.currency && c.currency.toLowerCase() === this.state.selectedPrice.currency?.toLowerCase());
          const currencySymbol = currencyObj?.symbol || (this.state.selectedPrice.currency === 'usd' ? '$' : this.state.selectedPrice.currency === 'cad' ? 'C$' : '');
          const currencyLabel = currencyObj?.isoLabel || this.state.selectedPrice.currency?.toUpperCase() || '';
          
          const pricePerUnit = dictPrice.pricePerUnit / 100;
          const listPricePerUnit = dictPrice.listPricePerUnit ? dictPrice.listPricePerUnit / 100 : null;
          const users = this.state.totalAdminUsers || 0;
          const isYearly = this.state.selectedPrice.interval === 'year';
          
          // Calculate amounts
          const baseAmount = listPricePerUnit || pricePerUnit;
          const amount = isYearly ? baseAmount * users * 12 : baseAmount * users;
          const discount = listPricePerUnit ? (isYearly ? (listPricePerUnit - pricePerUnit) * users * 12 : (listPricePerUnit - pricePerUnit) * users) : 0;
          const total = isYearly ? pricePerUnit * users * 12 : pricePerUnit * users;
          
          // Amount description
          const amountDescription = isYearly 
            ? `${currencySymbol}${baseAmount} ${currencyLabel} x ${users} users x 12`
            : `${currencySymbol}${baseAmount} ${currencyLabel} x ${users} users`;
          
          // Features list
          const featuresHtml = dictPrice.features || '';
          const featuresMatch = featuresHtml.match(/<ul>(.*?)<\/ul>/s);
          const featuresList = featuresMatch ? featuresMatch[1].split('</li>').map(li => li.replace(/<li>/g, '').trim()).filter(f => f) : [];
          const displayFeatures = featuresList.slice(0, 4);
          const hasMoreFeatures = featuresList.length > 4;
          
          // Features description (text before <ul>)
          const featuresDescMatch = featuresHtml.match(/<p>(.*?)<\/p>/);
          const featuresDescription = featuresDescMatch ? featuresDescMatch[1] : '';
          
          return `
            <div class="tenant-creation-form-price-selected-resume">
              <div class="tenant-creation-form-price-selected-resume-title">
                <h2>${dictPrice.name}</h2>
                ${dictPrice.remark ? `
                  <div class="tenant-creation-form-price-selected-chip">
                    <p>${dictPrice.remark}</p>
                  </div>
                ` : ''}
              </div>
              
              <p class="tenant-creation-form-price-selected-price">
                ${listPricePerUnit ? `
                  <span class="tenant-creation-form-price-selected-list-price">
                    ${currencySymbol}${listPricePerUnit.toFixed(2)}
                  </span>
                ` : ''}
                <span>${currencySymbol}${pricePerUnit.toFixed(2)}</span>
                <span class="tenant-creation-form-price-selected-price">${currencyLabel}</span>
                <span class="tenant-creation-form-price-selected-description">/${isYearly ? 'user/year' : 'user/month'}</span>
              </p>
              
              ${featuresDescription ? `
                <p class="tenant-creation-form-price-selected-features-description">${featuresDescription}</p>
              ` : ''}
              
              ${featuresList.length > 0 ? `
                <ul class="tenant-creation-form-price-selected-features">
                  ${displayFeatures.map(feature => `
                    <li>
                      <span style="color: var(--primaryColor); margin-right: 8px;">‚úì</span>
                      <span>${feature}</span>
                    </li>
                  `).join('')}
                </ul>
                ${hasMoreFeatures ? `
                  <div class="tenant-creation-form-price-selected-features-button">
                    <a href="#" onclick="event.preventDefault(); this.parentElement.previousElementSibling.innerHTML = \`${featuresList.map(f => `<li><span style='color: var(--primaryColor); margin-right: 8px;'>‚úì</span><span>${f}</span></li>`).join('')}\`; this.style.display='none';" class="link-text">
                      ${dict.tenantsignupsummary_displayfeatures || 'Display all features'}
                    </a>
                  </div>
                ` : ''}
              ` : ''}
              
              <hr style="margin: 24px 0; border: none; border-top: 1px solid #e5e7eb;" />
              
              <h3 class="tenant-creation-form-price-selected-resume-section-title">
                ${dict.tenantsignupsummary_tabletitle?.replace('[[frequency]]', isYearly ? (dict.tenantsignupsubscription_yearlytab || 'yearly').toLowerCase() : (dict.tenantsignupsubscription_monthlytab || 'monthly').toLowerCase()) || 'Recurring ' + (isYearly ? 'yearly' : 'monthly') + ' cost'}
              </h3>
              
              <div class="tenant-creation-form-price-selected-resume-section-line">
                <span class="tenant-creation-form-price-selected-resume-section-line-title">${dictPrice.name}</span>
                <span class="tenant-creation-form-price-selected-resume-section-line-amount">
                  ${currencySymbol}${amount.toFixed(2)} ${currencyLabel}
                </span>
                <p class="tenant-creation-form-price-selected-resume-section-line-description">${amountDescription}</p>
              </div>
              
              ${discount > 0 ? `
                <div class="tenant-creation-form-price-selected-resume-section-line">
                  <span class="tenant-creation-form-price-selected-resume-section-line-title">
                    ${dict.tenantsignupsummary_tablediscountlabel || 'Discount applied'}
                  </span>
                  <span class="tenant-creation-form-price-selected-resume-section-line-amount discount-amount" style="color: var(--primaryColor);">
                    ${currencySymbol}${discount.toFixed(2)} ${currencyLabel}
                  </span>
                </div>
              ` : ''}
              
              <hr style="margin: 24px 0; border: none; border-top: 1px solid #e5e7eb;" />
              
              <div class="tenant-creation-form-price-selected-total-section-line">
                <span class="tenant-creation-form-price-selected-total-section-line-title">
                  ${dict.tenantsignupsummary_tabletotallabel || "Today's total"}
                </span>
                <span class="tenant-creation-form-price-selected-total-section-line-amount">
                  ${currencySymbol}${total.toFixed(2)} ${currencyLabel}
                </span>
                <p class="tenant-creation-form-price-selected-total-section-line-description">
                  ${dict.tenantsignupsummary_tabledisclaimerlabel || 'Annual packages function the same as monthly packages with a yearly charge with a discount applied.'}
                </p>
              </div>
            </div>
          `;
        }

        async attachListeners() {
          // Step 1 listeners
          if (this.state.currentStep === 0) {
            const emailInput = document.getElementById('email-input');
            const passwordInput = document.getElementById('password-input');
            const confirmPasswordInput = document.getElementById('confirm-password-input');
            const nameInput = document.getElementById('tenant-name-input');
            const domainInput = document.getElementById('tenant-domain-input');
            const regionSelect = document.getElementById('region-select');

            if (emailInput) {
              emailInput.addEventListener('input', (e) => {
                this.state.email = e.target.value;
                this.clearError('email-error');
              });
              emailInput.addEventListener('blur', () => this.validateStep1());
            }

            if (passwordInput) {
              passwordInput.addEventListener('input', (e) => {
                this.state.password = e.target.value;
                this.clearError('password-error');
              });
              passwordInput.addEventListener('blur', () => this.validateStep1());
            }

            if (confirmPasswordInput) {
              confirmPasswordInput.addEventListener('input', (e) => {
                this.state.confirmPassword = e.target.value;
                this.clearError('confirm-password-error');
              });
              confirmPasswordInput.addEventListener('blur', () => this.validateStep1());
            }

            if (nameInput) {
              nameInput.addEventListener('input', (e) => {
                this.state.tenantName = e.target.value;
                this.clearError('tenant-name-error');
              });
              nameInput.addEventListener('blur', () => this.validateStep1());
            }

            if (domainInput) {
              domainInput.addEventListener('input', (e) => {
                this.state.tenantDomain = e.target.value.toLowerCase().replace(/[^a-z0-9-]/g, '');
                e.target.value = this.state.tenantDomain;
                this.clearError('tenant-domain-error');
              });
              domainInput.addEventListener('blur', () => {
                this.validateStep1();
                this.checkDomainAvailability();
              });
            }

            if (regionSelect) {
              regionSelect.addEventListener('change', (e) => {
                this.state.region = e.target.value;
                this.clearError('region-error');
              });
            }
          }

          // Step 2 listeners
          if (this.state.currentStep === 1) {
            const usersInput = document.getElementById('total-admin-users-input');
            if (usersInput) {
              usersInput.addEventListener('input', (e) => {
                const value = parseInt(e.target.value, 10) || 0;
                this.state.totalAdminUsers = value;
                this.clearError('users-error');
              });
              usersInput.addEventListener('blur', () => {
                if (this.state.selectedPrice) {
                  const minUsers = parseInt(this.state.selectedPrice.metadata?.['product.startingUsers'] || '0', 10);
                  if (this.state.totalAdminUsers < minUsers) {
                    this.state.totalAdminUsers = minUsers;
                    usersInput.value = minUsers;
                  }
                }
              });
            }
          }

          // Step 3 listeners - Initialize Stripe Elements
          if (this.state.currentStep === 2) {
            const cardholderNameInput = document.getElementById('cardholder-name-input');
            if (cardholderNameInput) {
              cardholderNameInput.addEventListener('input', (e) => {
                this.state.cardholderName = e.target.value;
                this.clearValidationError();
              });
            }

            // Initialize Stripe Elements if public key is available
            if (this.state.stripePublicKey) {
              setTimeout(async () => {
                try {
                  const initialized = await stripeService.initialize(this.state.stripePublicKey);
                  if (initialized) {
                    const cardElement = await stripeService.createCardElement('card-element');
                    if (cardElement) {
                      // Listen for card element errors
                      cardElement.on('change', (event) => {
                        const errorElement = document.getElementById('card-element-error');
                        if (errorElement) {
                          if (event.error) {
                            errorElement.textContent = event.error.message;
                            errorElement.style.display = 'block';
                          } else {
                            errorElement.textContent = '';
                            errorElement.style.display = 'none';
                          }
                        }
                      });
                    }
                  }
                } catch (error) {
                  // Stripe initialization failed
                  const errorElement = document.getElementById('card-element-error');
                  if (errorElement) {
                    errorElement.textContent = 'Failed to initialize payment form. Please refresh the page.';
                    errorElement.style.display = 'block';
                  }
                }
              }, 300);
            } else {
              // Try to reload Stripe key if it's not available yet
              await this.loadStripePublicKey();
              if (this.state.stripePublicKey) {
                setTimeout(async () => {
                  try {
                    const initialized = await stripeService.initialize(this.state.stripePublicKey);
                    if (initialized) {
                      await stripeService.createCardElement('card-element');
                    }
                  } catch (error) {
                    // Stripe initialization failed
                  }
                }, 300);
              }
            }
          }

          // Step 4 (Summary) listeners - Add direct event listener to button
          if (this.state.currentStep === 3) {
            const nextButton = document.getElementById('wizard-next-button');
            if (nextButton) {
              // Remove any existing listeners
              const newButton = nextButton.cloneNode(true);
              nextButton.parentNode.replaceChild(newButton, nextButton);
              
              // Add new listener
              newButton.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('üîµ Button clicked directly, calling nextStep()');
                if (window.tenantWizard) {
                  window.tenantWizard.nextStep();
                } else {
                  console.error('‚ùå tenantWizard not found in window');
                }
              });
            }
          }
        }

        validateStep1() {
          let isValid = true;
          this.state.validationError = null;
          const dict = this.state.dictionary || {};

          // Email validation
          if (!this.state.email || this.state.email.trim().length === 0) {
            this.showError('email-error', dict.globalparams_mandatoryfield || 'Email is required');
            isValid = false;
          } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(this.state.email)) {
            this.showError('email-error', dict.signup_emailinvalid || 'Please enter a valid email address');
            isValid = false;
          }

          // Password validation
          if (!this.state.password || this.state.password.length === 0) {
            this.showError('password-error', dict.globalparams_mandatoryfield || 'Password is required');
            isValid = false;
          } else if (this.state.password.length < 8) {
            this.showError('password-error', dict.signup_passwordminlength || 'Password must be at least 8 characters');
            isValid = false;
          }

          // Confirm password validation
          if (!this.state.confirmPassword || this.state.confirmPassword.length === 0) {
            this.showError('confirm-password-error', dict.signup_confirmpasswordrequired || 'Please confirm your password');
            isValid = false;
          } else if (this.state.password !== this.state.confirmPassword) {
            this.showError('confirm-password-error', dict.signup_passwordsdonotmatch || 'Passwords do not match');
            isValid = false;
          }

          // Business name validation
          if (!this.state.tenantName || this.state.tenantName.trim().length === 0) {
            this.showError('tenant-name-error', dict.globalparams_mandatoryfield || 'Business name is required');
            isValid = false;
          }

          // Domain validation
          if (!this.state.tenantDomain || this.state.tenantDomain.trim().length === 0) {
            this.showError('tenant-domain-error', dict.globalparams_mandatoryfield || 'Domain is required');
            isValid = false;
          } else if (!/^[a-z0-9-]+$/.test(this.state.tenantDomain)) {
            this.showError('tenant-domain-error', dict.tenantsetupname_tenantsubdomaininvalid || 'Domain can only contain lowercase letters, numbers, and hyphens');
            isValid = false;
          }

          // Region validation
          if (!this.state.region) {
            this.showError('region-error', dict.globalparams_mandatoryfield || 'Region is required');
            isValid = false;
          }

          return isValid;
        }

        async checkDomainAvailability() {
          if (!this.state.tenantDomain) return;

          try {
            const token = await auth.getAccessToken();
            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const tenantApi = isSandbox
              ? 'https://tenants-gateway-api-sbx.sidedrawersbx.com/api/v1/tenants/'
              : 'https://tenants-gateway-api.sidedrawer.com/api/v1/tenants/';

            const headers = { 'Content-Type': 'application/json' };
            if (token) {
              headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(`${tenantApi}tenant/branding/brand-code/${this.state.tenantDomain}`, { headers });

            if (response.ok) {
              const brand = await response.json();
              if (brand.brandCode !== 'sidedrawer' || this.state.tenantDomain === 'sidedrawer') {
                const dict = this.state.dictionary || {};
                this.showError('tenant-domain-error', dict.tenantsetupname_tenantsubdomaintaken || 'Domain is already taken');
              }
            } else if (response.status === 404) {
              // Domain is available
              this.clearError('tenant-domain-error');
            }
          } catch (error) {
            console.error('‚ùå Error checking domain:', error);
          }
        }

        async nextStep() {
          console.log('üîµ nextStep() called, currentStep:', this.state.currentStep);
          const dict = this.state.dictionary || {};
          
          if (this.state.currentStep === 0) {
            if (!this.validateStep1()) {
              this.state.validationError = dict.globalparams_fillrequiredfields || 'Please fill in all required fields';
              this.render();
              return;
            }
            this.state.currentStep = 1;
          } else if (this.state.currentStep === 1) {
            if (!this.state.selectedPrice) {
              this.state.validationError = dict.tenantsetupsubscription_selectplan || 'Please select a subscription plan';
              this.render();
              return;
            }
            if (!this.state.totalAdminUsers || this.state.totalAdminUsers < 1) {
              this.state.validationError = dict.tenantsignupsubscription_usersrequired || 'Please enter the number of admin users';
              this.render();
              return;
            }
            this.state.currentStep = 2;
            await this.loadPaymentMethods();
            // Re-render to show step 3 and initialize Stripe Elements
            this.render();
            this.attachListeners();
          } else if (this.state.currentStep === 2) {
            // Validate payment method
            if (!this.state.selectedPaymentMethod && !this.state.stripePublicKey) {
              this.state.validationError = dict.paymentdetails_selectpaymentmethod || 'Please select or add a payment method';
              this.render();
              return;
            }
            
            // If using Stripe Elements, create payment method token now (before moving to summary)
            if (!this.state.selectedPaymentMethod && this.state.stripePublicKey && stripeService.cardElement) {
              const cardholderName = document.getElementById('cardholder-name-input')?.value;
              if (!cardholderName) {
                this.state.validationError = dict.paymentdetails_addnewcardname || 'Cardholder name is required';
                this.render();
                return;
              }
              
              if (!this.state.billingAddress) {
                this.state.validationError = dict.paymentdetails_addnewcardbillingaddress || 'Billing address is required';
                this.render();
                return;
              }
              
              // Create payment method token
              console.log('üîµ Creating payment method token on step 2...');
              const { paymentMethodId: pmId, error } = await stripeService.createPaymentMethod({
                name: cardholderName,
                address: {
                  line1: this.state.billingAddress.line1,
                  city: this.state.billingAddress.city,
                  state: this.state.billingAddress.state,
                  postal_code: this.state.billingAddress.postalCode,
                  country: this.state.billingAddress.country
                }
              });
              
              if (error || !pmId) {
                this.state.validationError = error?.message || 'Failed to create payment method';
                this.render();
                return;
              }
              
              // Store payment method token in state
              this.state.paymentMethodToken = pmId;
              console.log('üîµ Payment method token stored:', pmId);
            }
            
            this.state.currentStep = 3;
            this.render();
            this.attachListeners();
          } else if (this.state.currentStep === 3) {
            // Final step: create tenant
            console.log('üîµ Step 3: Calling createTenant()');
            try {
              await this.createTenant();
            } catch (error) {
              console.error('‚ùå Error in nextStep (step 3):', error);
              const dict = this.state.dictionary || {};
              this.state.validationError = error.message || (dict.globalparams_error || 'Failed to create account');
              this.render();
            }
            return;
          }

          this.state.validationError = null;
          this.render();
        }

        previousStep() {
          if (this.state.currentStep > 0) {
            this.state.currentStep--;
            this.state.validationError = null;
            this.render();
          }
        }

        selectPrice(priceId) {
          const price = this.state.prices.find(p => p.id === priceId);
          if (price) {
            this.state.selectedPrice = price;
            this.state.validationError = null;
            
            // Set minimum users from price metadata
            const minUsers = parseInt(price.metadata?.['product.startingUsers'] || '0', 10);
            if (this.state.totalAdminUsers < minUsers) {
              this.state.totalAdminUsers = minUsers;
            }
            
            this.render();
            this.attachListeners();
          }
        }

        selectCurrency(currencyCode) {
          this.state.currency = currencyCode;
          this.state.selectedPrice = null; // Clear selection when currency changes
          this.updatePriceLists();
          this.render();
          this.attachListeners();
        }

        setPriceTab(tab) {
          this.state.priceTab = tab;
          // Update price lists to ensure correct filtering
          this.updatePriceLists();
          this.render();
          this.attachListeners();
        }

        showCurrencySelector() {
          const currencies = this.state.currencies.filter(c => c && c.currency && c.enabled);
          if (currencies.length === 0) {
            return;
          }

          const dict = this.state.dictionary || {};
          const currentCurrency = this.state.currency;

          const modalHtml = `
            <div class="modal-overlay" id="currency-modal-overlay">
              <div class="modal-dialog">
                <div class="modal-header">
                  <h3 class="modal-title">${dict.selectcurrencydialog_title || 'Select Currency'}</h3>
                  <button class="modal-close" onclick="tenantWizard.closeCurrencyModal()">√ó</button>
                </div>
                <div class="modal-body">
                  <div class="modal-description">
                    ${dict.selectcurrencydialog_description || 'Choose your preferred currency'}
                  </div>
                  <div class="currency-list">
                    ${currencies.map(currency => {
                      const isSelected = currency.currency.toLowerCase() === currentCurrency;
                      const flagUrl = `/assets/flags/${currency.flag?.toLowerCase() || currency.currency.toLowerCase()}.svg`;
                      return `
                        <div 
                          class="currency-item ${isSelected ? 'selected' : ''}"
                          onclick="tenantWizard.selectCurrencyFromModal('${currency.currency.toLowerCase()}')"
                        >
                          <img src="${flagUrl}" alt="${currency.currency}" class="currency-flag" onerror="this.style.display='none'">
                          <div class="currency-info">
                            <div class="currency-iso">${currency.isoLabel || currency.currency.toUpperCase()}</div>
                            <div class="currency-name">${currency.currencyName || ''}</div>
                          </div>
                          ${isSelected ? '<span class="currency-check">‚úì</span>' : ''}
                        </div>
                      `;
                    }).join('')}
                  </div>
                </div>
              </div>
            </div>
          `;

          // Remove existing modal if any
          const existingModal = document.getElementById('currency-modal-overlay');
          if (existingModal) {
            existingModal.remove();
          }

          // Add modal to body
          document.body.insertAdjacentHTML('beforeend', modalHtml);

          // Close on overlay click
          document.getElementById('currency-modal-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'currency-modal-overlay') {
              this.closeCurrencyModal();
            }
          });
        }

        closeCurrencyModal() {
          const modal = document.getElementById('currency-modal-overlay');
          if (modal) {
            modal.remove();
          }
        }

        selectCurrencyFromModal(currencyIso) {
          this.state.currency = currencyIso;
          this.updatePriceLists();
          this.state.selectedPrice = null; // Clear selection when currency changes
          this.closeCurrencyModal();
          this.render();
        }

        async loadPaymentMethods() {
          try {
            const token = await auth.getAccessToken();
            if (!token) return;

            // Get user account to find customer ID
            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const userApi = isSandbox
              ? 'https://user-api-sbx.sidedrawersbx.com'
              : 'https://user-api.sidedrawer.com';

            const userResponse = await fetch(`${userApi}/me`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });

            if (userResponse.ok) {
              const user = await userResponse.json();
              
              // Get customer ID (assuming it's stored in user metadata or separate call)
              // For now, we'll create customer if needed during payment method addition
            }
          } catch (error) {
            console.error('‚ùå Error loading payment methods:', error);
          }
        }

        selectPaymentMethod(paymentMethodId) {
          const pm = this.state.paymentMethods.find(p => p.id === paymentMethodId);
          if (pm) {
            this.state.selectedPaymentMethod = pm;
            this.render();
          }
        }

        showBillingAddressDialog() {
          const dict = this.state.dictionary || {};
          const currentAddress = this.state.billingAddress || {};

          const modalHtml = `
            <div class="modal-overlay" id="billing-address-modal-overlay">
              <div class="modal-dialog" style="max-width: 600px;">
                <div class="modal-header">
                  <h3 class="modal-title">${dict.paymentdetails_addnewcardbillingaddress || 'Billing Address'}</h3>
                  <button class="modal-close" onclick="tenantWizard.closeBillingAddressModal()">√ó</button>
                </div>
                <div class="modal-body">
                  <form class="billing-address-form" id="billing-address-form" onsubmit="event.preventDefault(); tenantWizard.saveBillingAddress();">
                    <div class="wizard-form-group">
                      <label class="wizard-form-label">Street Address</label>
                      <input 
                        type="text" 
                        class="wizard-form-input" 
                        id="billing-line1"
                        placeholder="${dict.paymentdetails_billingaddressline1 || 'Street address'}"
                        value="${currentAddress.line1 || ''}"
                        required
                      />
                    </div>

                    <div class="wizard-form-group">
                      <label class="wizard-form-label">City</label>
                      <input 
                        type="text" 
                        class="wizard-form-input" 
                        id="billing-city"
                        placeholder="${dict.paymentdetails_billingaddresscity || 'City'}"
                        value="${currentAddress.city || ''}"
                        required
                      />
                    </div>

                    <div class="wizard-form-group">
                      <label class="wizard-form-label">State/Province</label>
                      <input 
                        type="text" 
                        class="wizard-form-input" 
                        id="billing-state"
                        placeholder="${dict.paymentdetails_billingaddressstate || 'State/Province'}"
                        value="${currentAddress.state || ''}"
                        required
                      />
                    </div>

                    <div class="wizard-form-group">
                      <label class="wizard-form-label">Postal Code</label>
                      <input 
                        type="text" 
                        class="wizard-form-input" 
                        id="billing-postal"
                        placeholder="${dict.paymentdetails_billingaddresspostal || 'Postal Code'}"
                        value="${currentAddress.postalCode || ''}"
                        required
                      />
                    </div>

                    <div class="wizard-form-group">
                      <label class="wizard-form-label">Country</label>
                      <select 
                        class="wizard-form-input" 
                        id="billing-country"
                        required
                        style="padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px; background-color: white;"
                      >
                        <option value="">${dict.paymentdetails_billingaddresscountry || 'Select Country'}</option>
                        ${this.getCountryOptions().map(country => `
                          <option value="${country.code}" ${currentAddress.country === country.code ? 'selected' : ''}>
                            ${country.code} ${country.name}
                          </option>
                        `).join('')}
                      </select>
                    </div>

                    <div class="wizard-footer" style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #e5e7eb;">
                      <button type="button" class="btn" onclick="tenantWizard.closeBillingAddressModal()">
                        ${dict.globalparams_cancel || 'Cancel'}
                      </button>
                      <button type="submit" class="btn btn-success">
                        ${dict.globalparams_save || 'Save'}
                      </button>
                    </div>
                  </form>
                </div>
              </div>
            </div>
          `;

          // Remove existing modal if any
          const existingModal = document.getElementById('billing-address-modal-overlay');
          if (existingModal) {
            existingModal.remove();
          }

          // Add modal to body
          document.body.insertAdjacentHTML('beforeend', modalHtml);

          // Close on overlay click
          document.getElementById('billing-address-modal-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'billing-address-modal-overlay') {
              this.closeBillingAddressModal();
            }
          });
        }

        closeBillingAddressModal() {
          const modal = document.getElementById('billing-address-modal-overlay');
          if (modal) {
            modal.remove();
          }
        }

        saveBillingAddress() {
          const line1 = document.getElementById('billing-line1')?.value;
          const city = document.getElementById('billing-city')?.value;
          const state = document.getElementById('billing-state')?.value;
          const postalCode = document.getElementById('billing-postal')?.value;
          const country = document.getElementById('billing-country')?.value;

          if (line1 && city && state && postalCode && country) {
            // Save cardholder name before re-rendering
            const cardholderNameInput = document.getElementById('cardholder-name-input');
            if (cardholderNameInput) {
              this.state.cardholderName = cardholderNameInput.value;
            }

            this.state.billingAddress = {
              line1,
              city,
              state,
              postalCode,
              country
            };
            this.closeBillingAddressModal();
            
            // Update only the billing address display without re-rendering the entire step
            // This preserves the Stripe card element and cardholder name
            const billingAddressSection = document.querySelector('.billing-address-section');
            if (billingAddressSection) {
              const addressDisplay = billingAddressSection.querySelector('div[style*="margin-top: 12px"]');
              if (addressDisplay) {
                addressDisplay.innerHTML = `
                  ${this.state.billingAddress.line1}<br>
                  ${this.state.billingAddress.city}, ${this.state.billingAddress.state} ${this.state.billingAddress.postalCode}<br>
                  ${this.state.billingAddress.country}
                `;
              } else {
                // If display doesn't exist, create it
                const displayDiv = document.createElement('div');
                displayDiv.style.cssText = 'margin-top: 12px; padding: 12px; background: white; border-radius: 4px; color: #374151;';
                displayDiv.innerHTML = `
                  ${this.state.billingAddress.line1}<br>
                  ${this.state.billingAddress.city}, ${this.state.billingAddress.state} ${this.state.billingAddress.postalCode}<br>
                  ${this.state.billingAddress.country}
                `;
                billingAddressSection.appendChild(displayDiv);
              }
              
              // Update button text
              const updateButton = billingAddressSection.querySelector('button');
              if (updateButton) {
                const dict = this.state.dictionary || {};
                updateButton.textContent = dict.paymentdetails_updatebillingaddress || 'Update Billing Address';
              }
            }
          }
        }

        async createTenant() {
          console.log('üîµ createTenant() called');
          console.log('üîµ State:', {
            selectedPaymentMethod: this.state.selectedPaymentMethod,
            stripePublicKey: this.state.stripePublicKey ? 'Set' : 'Not set',
            selectedPrice: this.state.selectedPrice?.id,
            totalAdminUsers: this.state.totalAdminUsers
          });
          
          const dict = this.state.dictionary || {};
          
          // Validate payment method
          if (!this.state.selectedPaymentMethod && !this.state.stripePublicKey) {
            console.warn('‚ö†Ô∏è No payment method available');
            this.state.validationError = dict.paymentdetails_selectpaymentmethod || 'Please add a payment method';
            this.render();
            return;
          }

          // If using Stripe Elements, create payment method first
          let paymentMethodId = this.state.selectedPaymentMethod?.id || this.state.paymentMethodToken;
          
          // If no payment method selected but Stripe is available, try to create one from card element
          // Note: On step 3, the card element container might not exist, so we use the stored token
          if (!paymentMethodId && this.state.stripePublicKey) {
            console.log('üîµ No payment method selected, trying to create from Stripe Elements');
            
            // Check if Stripe is initialized and card element exists
            if (!stripeService.stripe) {
              console.log('üîµ Stripe not initialized, initializing...');
              try {
                await stripeService.initialize(this.state.stripePublicKey);
                console.log('üîµ Stripe initialized successfully');
              } catch (error) {
                console.error('‚ùå Failed to initialize Stripe:', error);
                this.state.validationError = 'Failed to initialize payment system. Please refresh the page.';
                this.render();
                return;
              }
            } else {
              console.log('üîµ Stripe already initialized');
            }

            // Check if card element exists, if not try to create it
            if (!stripeService.cardElement) {
              console.log('üîµ Card element not found, trying to create it...');
              const cardElementContainer = document.getElementById('card-element');
              if (!cardElementContainer) {
                console.error('‚ùå card-element container not found in DOM');
                this.state.validationError = 'Payment form not available. Please go back to payment step and complete the form.';
                this.render();
                return;
              }
              try {
                await stripeService.createCardElement('card-element');
                console.log('üîµ Card element created successfully');
              } catch (error) {
                console.error('‚ùå Failed to create card element:', error);
                this.state.validationError = 'Payment form not ready. Please complete the payment form.';
                this.render();
                return;
              }
            } else {
              console.log('üîµ Card element already exists');
            }

            const cardholderName = document.getElementById('cardholder-name-input')?.value;
            console.log('üîµ Cardholder name:', cardholderName ? 'Found' : 'Missing');
            if (!cardholderName) {
              this.state.validationError = dict.paymentdetails_addnewcardname || 'Cardholder name is required';
              this.render();
              return;
            }

            console.log('üîµ Billing address:', this.state.billingAddress ? 'Found' : 'Missing');
            if (!this.state.billingAddress) {
              this.state.validationError = dict.paymentdetails_addnewcardbillingaddress || 'Billing address is required';
              this.render();
              return;
            }

            // Create payment method token
            console.log('üîµ Creating payment method token...');
            const { paymentMethodId: pmId, error } = await stripeService.createPaymentMethod({
              name: cardholderName,
              address: {
                line1: this.state.billingAddress.line1,
                city: this.state.billingAddress.city,
                state: this.state.billingAddress.state,
                postal_code: this.state.billingAddress.postalCode,
                country: this.state.billingAddress.country
              }
            });

            if (error || !pmId) {
              this.state.validationError = error?.message || 'Failed to create payment method';
              this.render();
              return;
            }

            paymentMethodId = pmId;
          }

          // Final validation: must have payment method ID
          if (!paymentMethodId) {
            this.state.validationError = dict.paymentdetails_selectpaymentmethod || 'Please add a payment method';
            this.render();
            return;
          }

          this.state.loading = true;
          this.state.validationError = null;
          this.render();

          try {
            // Call secure backend signup endpoint
            await this.signupAndCreateTenant(paymentMethodId);
          } catch (error) {
            console.error('‚ùå Error creating tenant:', error);
            this.state.loading = false;
            this.state.validationError = error.message || 'Failed to create tenant';
            this.render();
          }
        }

        async signupAndCreateTenant(paymentMethodId) {
          console.log('üîµ signupAndCreateTenant() called with paymentMethodId:', paymentMethodId);
          try {
            // Collect signup data from state
            const signupData = {
              email: this.state.email,
              password: this.state.password,
              firstName: this.state.tenantName.split(' ')[0] || this.state.tenantName,
              lastName: this.state.tenantName.split(' ').slice(1).join(' ') || '',
              tenantName: this.state.tenantName,
              tenantDomain: this.state.tenantDomain,
              region: this.state.region,
              priceId: this.state.selectedPrice?.id,
              paymentMethodId: paymentMethodId
            };

            if (!signupData.email || !signupData.password) {
              this.state.validationError = 'Email and password are required';
              this.state.loading = false;
              this.render();
              return;
            }

            // Prepare request body for backend
            const requestBody = {
              email: signupData.email,
              password: signupData.password,
              firstName: signupData.firstName,
              lastName: signupData.lastName,
              tenantName: signupData.tenantName,
              tenantDomain: signupData.tenantDomain,
              region: signupData.region,
              priceId: signupData.priceId,
              paymentMethodId: signupData.paymentMethodId
            };

            // TODO: Add CAPTCHA token when backend is ready
            // const captchaToken = await this.getCaptchaToken();
            // requestBody.captchaToken = captchaToken;

            // TODO: Add request signing when backend is ready
            // const signature = this.signRequest(requestBody);
            // headers['X-Request-Signature'] = signature.signature;
            // headers['X-Request-Timestamp'] = signature.timestamp.toString();
            // headers['X-API-Key'] = signature.apiKey;

            // Call secure backend signup endpoint
            const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
            const backendUrl = isSandbox
              ? 'https://api-sbx.sidedrawersbx.com/api/v1/auth/signup-and-login'
              : 'https://api.sidedrawer.com/api/v1/auth/signup-and-login';

            console.log('üîµ Making POST request to:', backendUrl);
            console.log('üîµ Request body:', JSON.stringify(requestBody, null, 2));

            const headers = {
              'Content-Type': 'application/json'
            };

            // TODO: Add CAPTCHA header when backend is ready
            // headers['X-Captcha-Token'] = captchaToken;

            // TODO: Add request signing headers when backend is ready
            // headers['X-Request-Signature'] = signature.signature;
            // headers['X-Request-Timestamp'] = signature.timestamp.toString();
            // headers['X-API-Key'] = signature.apiKey;

            const response = await fetch(backendUrl, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(errorData.error_description || errorData.error || 'Signup failed');
            }

            const result = await response.json();

            // Store tokens
            if (result.accessToken && result.idToken) {
              await auth.setZohoSession({
                accessToken: result.accessToken,
                idToken: result.idToken,
                expiresAt: (Date.now() + (result.expiresIn * 1000)).toString(),
                refreshToken: result.refreshToken || ''
              });

              // Show success
              this.showSuccess();
            } else {
              throw new Error('No tokens received from backend');
            }

          } catch (error) {
            console.error('‚ùå Signup error:', error);
            
            // If backend endpoint doesn't exist yet (404), show ready message
            if (error.message.includes('404') || error.message.includes('Failed to fetch')) {
              this.showBackendPendingMessage(paymentMethodId);
            } else {
              this.state.loading = false;
              this.state.validationError = error.message || 'Failed to create account';
              this.render();
            }
          }
        }

        showBackendPendingMessage(paymentMethodId) {
          const wizardContainer = document.getElementById('tenant-wizard');
          wizardContainer.innerHTML = `
            <div class="tenant-wizard">
              <div class="success-animation">
                <div class="success-icon">‚úì</div>
                <h2>Frontend Ready</h2>
                <p style="color: #6b7280; margin-top: 16px;">
                  All frontend validation is complete. Backend endpoint integration pending.
                </p>
                <div style="margin-top: 24px; padding: 20px; background: #f9fafb; border-radius: 8px; text-align: left;">
                  <h3 style="margin-bottom: 12px;">Account Details Ready:</h3>
                  <p><strong>Business Name:</strong> ${this.state.tenantName}</p>
                  <p><strong>Domain:</strong> ${this.state.tenantDomain}.sidedrawer.com</p>
                  <p><strong>Region:</strong> ${this.getCountryName(this.state.region)}</p>
                  <p><strong>Subscription:</strong> ${this.state.selectedPrice?.id}</p>
                  <p><strong>Payment Method:</strong> ${paymentMethodId ? 'Token: ' + paymentMethodId.substring(0, 20) + '...' : 'Selected'}</p>
                </div>
                <div style="margin-top: 24px; padding: 20px; background: #eff6ff; border-radius: 8px; text-align: left;">
                  <h3 style="margin-bottom: 12px;">Backend Endpoint Ready:</h3>
                  <p style="font-family: monospace; font-size: 13px; margin: 8px 0;">
                    <strong>POST</strong> /api/v1/auth/signup-and-login
                  </p>
                  <p style="font-size: 13px; color: #6b7280; margin-top: 12px;">
                    The frontend will automatically call this endpoint when it's available.
                    Request body includes: email, password, firstName, lastName, tenantName, 
                    tenantDomain, region, priceId, paymentMethodId
                  </p>
                </div>
                <button class="btn btn-success" onclick="location.reload()" style="margin-top: 24px;">
                  Close
                </button>
              </div>
            </div>
          `;
        }

        showSuccess() {
          const wizardContainer = document.getElementById('tenant-wizard');
          wizardContainer.innerHTML = `
            <div class="tenant-wizard">
              <div class="success-animation">
                <div class="success-icon">‚úì</div>
                <h2>Account Created Successfully!</h2>
                <p style="color: #6b7280; margin-top: 16px;">
                  Your SideDrawer account has been created and you are now logged in.
                </p>
                <button class="btn btn-success" onclick="location.reload()" style="margin-top: 24px;">
                  Continue
                </button>
              </div>
            </div>
          `;
        }

        // Helper methods
        getCountryName(countryCode) {
          const countries = {
            'US': 'United States',
            'CA': 'Canada',
            'GB': 'United Kingdom',
            'AU': 'Australia'
          };
          return countries[countryCode] || countryCode;
        }

        getCurrencyFlag(currency) {
          const flags = {
            'usd': 'üá∫üá∏',
            'cad': 'üá®üá¶',
            'gbp': 'üá¨üáß',
            'eur': 'üá™üá∫',
            'aud': 'üá¶üá∫'
          };
          return flags[currency.toLowerCase()] || 'üí≥';
        }

        formatPrice(amount, currency) {
          return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: currency.toUpperCase()
          }).format(amount / 100);
        }

        getDictionaryPrice(priceId) {
          if (!this.state.dictionary?.collections?.prices) return null;
          return this.state.dictionary.collections.prices.find(p => p.stripePriceId === priceId);
        }

        getDictionaryValue(key) {
          if (!this.state.dictionary) return null;
          return this.state.dictionary[key] || null;
        }

        getCountryOptions() {
          return [
            { code: 'AR', name: 'Argentina' },
            { code: 'AU', name: 'Australia' },
            { code: 'AT', name: 'Austria' },
            { code: 'BE', name: 'Belgium' },
            { code: 'BR', name: 'Brazil' },
            { code: 'CA', name: 'Canada' },
            { code: 'CL', name: 'Chile' },
            { code: 'CN', name: 'China' },
            { code: 'CO', name: 'Colombia' },
            { code: 'CR', name: 'Costa Rica' },
            { code: 'DK', name: 'Denmark' },
            { code: 'FI', name: 'Finland' },
            { code: 'FR', name: 'France' },
            { code: 'DE', name: 'Germany' },
            { code: 'GR', name: 'Greece' },
            { code: 'GT', name: 'Guatemala' },
            { code: 'HN', name: 'Honduras' },
            { code: 'HK', name: 'Hong Kong' },
            { code: 'IN', name: 'India' },
            { code: 'IE', name: 'Ireland' },
            { code: 'IT', name: 'Italy' },
            { code: 'JP', name: 'Japan' },
            { code: 'MX', name: 'Mexico' },
            { code: 'NL', name: 'Netherlands' },
            { code: 'NZ', name: 'New Zealand' },
            { code: 'NO', name: 'Norway' },
            { code: 'PA', name: 'Panama' },
            { code: 'PE', name: 'Peru' },
            { code: 'PH', name: 'Philippines' },
            { code: 'PL', name: 'Poland' },
            { code: 'PT', name: 'Portugal' },
            { code: 'PR', name: 'Puerto Rico' },
            { code: 'SG', name: 'Singapore' },
            { code: 'ZA', name: 'South Africa' },
            { code: 'ES', name: 'Spain' },
            { code: 'SE', name: 'Sweden' },
            { code: 'CH', name: 'Switzerland' },
            { code: 'TW', name: 'Taiwan' },
            { code: 'GB', name: 'United Kingdom' },
            { code: 'US', name: 'United States' },
            { code: 'UY', name: 'Uruguay' },
            { code: 'VE', name: 'Venezuela' }
          ].sort((a, b) => a.name.localeCompare(b.name));
        }

        showError(elementId, message) {
          const element = document.getElementById(elementId);
          if (element) {
            element.textContent = message;
            element.classList.add('show');
          }
        }

        clearError(elementId) {
          const element = document.getElementById(elementId);
          if (element) {
            element.textContent = '';
            element.classList.remove('show');
          }
        }

        clearValidationError() {
          this.state.validationError = null;
          const errorElement = document.querySelector('.validation-error');
          if (errorElement) {
            errorElement.remove();
          }
        }
      }

      // Initialize tenant creation wizard FIRST (before auth, so it's available when needed)
      const tenantWizard = new TenantCreationWizard();
      
      // Expose to window for onclick handlers and for SideDrawerAuth to access
      window.tenantWizard = tenantWizard;
      
      // Make sure it's available globally
      if (typeof tenantWizard === 'undefined') {
        console.error('‚ùå Failed to initialize TenantCreationWizard');
      } else {
        console.log('‚úÖ TenantCreationWizard initialized');
      }

      /**
       * PCI-COMPLIANT PAYMENT METHOD CREATION HELPER
       * 
       * This helper function demonstrates how to add a payment method using Stripe Elements.
       * Card data never touches your servers - only the paymentMethodId token is sent.
       * 
       * @param {string} stripePublicKey - Stripe public key (pk_test_... or pk_live_...)
       * @param {string} customerId - Customer ID from your backend
       * @param {object} billingDetails - Billing address details
       * @param {string} accessToken - OAuth access token for API calls
       * @param {boolean} setAsDefault - Whether to set as default payment method
       * @returns {Promise<object>} - { success: boolean, paymentMethod?: object, error?: string }
       */
      async function addPaymentMethodSecurely(stripePublicKey, customerId, billingDetails, accessToken, setAsDefault = true) {
        try {
          // Step 1: Initialize Stripe
          const initialized = await stripeService.initialize(stripePublicKey);
          if (!initialized) {
            return { success: false, error: 'Failed to initialize Stripe' };
          }

          // Step 2: Create card element (assumes HTML container exists)
          const cardElement = await stripeService.createCardElement('card-element');
          if (!cardElement) {
            return { success: false, error: 'Failed to create Stripe card element. Make sure #card-element container exists.' };
          }

          // Step 3: Create payment method token (PCI-compliant)
          const { paymentMethodId, error: stripeError } = await stripeService.createPaymentMethod(billingDetails);
          if (stripeError || !paymentMethodId) {
            return { success: false, error: stripeError?.message || 'Failed to create payment method' };
          }

          // Step 4: Send ONLY paymentMethodId to backend (NO card data)
          const isSandbox = OAUTH_CONFIG.audience.includes('sbx');
          const subscriptionApi = isSandbox
            ? 'https://subscription-api-sbx.sidedrawersbx.com'
            : 'https://subscription-api.sidedrawer.com';

          const response = await fetch(
            `${subscriptionApi}/customers/customer-id/${customerId}/payment-methods`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                paymentMethodId: paymentMethodId, // PCI-compliant: Only token, no card data
                setAsDefault: setAsDefault,
                name: billingDetails.name,
                billingAddress: {
                  line1: billingDetails.address.line1,
                  city: billingDetails.address.city,
                  state: billingDetails.address.state,
                  postalCode: billingDetails.address.postal_code,
                  country: billingDetails.address.country
                }
              })
            }
          );

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            return { success: false, error: errorData.error_description || errorData.error || 'Failed to add payment method' };
          }

          const paymentMethod = await response.json();
          console.log('‚úÖ Payment method added successfully:', paymentMethod.id);

          // Clean up Stripe Elements
          stripeService.unmountCardElement();

          return { success: true, paymentMethod };
        } catch (error) {
          console.error('‚ùå Error adding payment method:', error);
          return { success: false, error: error.message || 'Unknown error occurred' };
        }
      }

      /**
       * USAGE EXAMPLE:
       * 
       * 1. Add HTML for Stripe Elements:
       *    <div id="card-element-container" class="stripe-card-element-container">
       *      <div id="card-element"></div>
       *      <div id="card-element-error" class="stripe-error"></div>
       *    </div>
       * 
       * 2. Get Stripe public key from backend/config (or environment variable)
       *    const stripePublicKey = 'pk_test_...'; // Get from your backend API
       * 
       * 3. Call the helper function:
       *    const result = await addPaymentMethodSecurely(
       *      stripePublicKey,
       *      customerId,
       *      {
       *        name: 'John Doe',
       *        address: {
       *          line1: '123 Main St',
       *          city: 'Toronto',
       *          state: 'ON',
       *          postal_code: 'M5H 2N2',
       *          country: 'CA'
       *        }
       *      },
       *      accessToken,
       *      true // setAsDefault
       *    );
       * 
       *    if (result.success) {
       *      console.log('Payment method added:', result.paymentMethod);
       *    } else {
       *      console.error('Error:', result.error);
       *    }
       * 
       * IMPORTANT SECURITY NOTES:
       * - Card data (number, CVC, expiry) NEVER touches your servers
       * - Only paymentMethodId (token) is sent to backend
       * - Backend must accept paymentMethodId and use Stripe SDK to attach it
       * - This ensures PCI-DSS compliance (Requirement 3.4, 4.1, 3.2)
       */

      // Initialize auth manager (tenantWizard is already created above)
      const auth = new SideDrawerAuth();
      
      // Helper function to check session status (can be called from console)
      window.checkSideDrawerSession = async function() {
        console.log('üîç Checking SideDrawer Session Status...');
        console.log('='.repeat(60));
        
        // Check localStorage for session
        const sessionStr = localStorage.getItem('sdSession');
        console.log('üì¶ localStorage key "sdSession":', sessionStr ? 'FOUND' : 'NOT FOUND');
        
        if (sessionStr) {
          try {
            const session = JSON.parse(sessionStr);
            console.log('‚úÖ Session object parsed successfully');
            console.log('  Keys in session:', Object.keys(session));
            console.log('  Has accessToken:', !!session.accessToken);
            console.log('  Has refreshToken:', !!session.refreshToken);
            console.log('  Expires at:', session.expiresAt ? new Date(parseInt(session.expiresAt)).toISOString() : 'N/A');
            
            if (session.expiresAt) {
              const now = Date.now();
              const expiresAt = parseInt(session.expiresAt);
              const timeUntilExpiry = Math.floor((expiresAt - now) / 1000);
              console.log('  Time until expiry:', timeUntilExpiry, 'seconds');
              console.log('  Is expired:', timeUntilExpiry < 0 ? 'YES ‚ùå' : 'NO ‚úÖ');
            }
            
            if (session.refreshToken) {
              console.log('  Refresh token preview:', session.refreshToken.substring(0, 20) + '...');
            } else {
              console.log('  ‚ö†Ô∏è NO REFRESH TOKEN IN SESSION OBJECT!');
            }
          } catch (e) {
            console.error('‚ùå Failed to parse session:', e);
          }
        }
        
        // Check localStorage for separate refresh token
        const refreshTokenKey = 'sidedrawer_refresh_token';
        const refreshToken = localStorage.getItem(refreshTokenKey);
        console.log('üì¶ localStorage key "' + refreshTokenKey + '":', refreshToken ? 'FOUND ‚úÖ' : 'NOT FOUND ‚ùå');
        if (refreshToken) {
          console.log('  Refresh token preview:', refreshToken.substring(0, 20) + '...');
        }
        
        // Check sessionStorage
        const sessionStorageStr = sessionStorage.getItem('sdSession');
        console.log('üì¶ sessionStorage key "sdSession":', sessionStorageStr ? 'FOUND' : 'NOT FOUND');
        
        console.log('='.repeat(60));
        
        if (!sessionStr || !refreshToken) {
          console.log('‚ö†Ô∏è NO REFRESH TOKEN FOUND!');
          console.log('');
          console.log('üìã This means:');
          console.log('  1. Your session was created BEFORE refresh token storage was added');
          console.log('  2. OR the OAuth response did not include refresh_token');
          console.log('  3. Session cannot be automatically refreshed');
          console.log('');
          console.log('‚úÖ SOLUTION: Re-authenticate to get a fresh session with refresh token');
          console.log('  - Click "Connect to SideDrawer" button in the widget');
          console.log('  - OR run: auth.startOAuthFlow()');
          console.log('');
          console.log('‚úÖ After re-authentication, refresh token will be stored in:');
          console.log('  - Session object: sdSession.refreshToken');
          console.log('  - localStorage: sidedrawer_refresh_token');
        } else {
          console.log('‚úÖ Refresh token found! Session can be automatically refreshed.');
          console.log('üí° Run: auth.checkConnection() to test refresh');
        }
      };
      
      console.log('üí° Run checkSideDrawerSession() in console to check session status');
    </script>
  </body>
</html>
